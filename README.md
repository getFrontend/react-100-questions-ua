| Номер запитання | Назва запитання |
| --- | --- |
| 1 | [Що таке React?](#що-таке-react?) |
| 2 | [Які основні переваги використання React?](#які-основні-переваги-використання-react?) |
| 3 | [Що таке JSX?](#що-таке-jsx?) |
| 4 | [Які основні відмінності між компонентами класів і функціональними компонентами в React?](#які-основні-відмінності-між-компонентами-класів-і-функціональними-компонентами-в-react?) |
| 5 | [Що таке Virtual DOM, та як він працює?](#що-таке-virtual-dom,-та-як-він-працює?) |
| 6 | [Які методи життєвого циклу компонентів ви знаєте?](#які-методи-життєвого-циклу-компонентів-ви-знаєте?) |
| 7 | [Що таке "стан" (state) компонента в React?](#що-таке-"стан"-(state)-компонента-в-react?) |
| 8 | [Як оновити стан компонента?](#як-оновити-стан-компонента?) |
| 9 | [Что такое пропсы (props) в React?](#что-такое-пропсы-(props)-в-react?) |
| 10 | [У чому різниця між станом і пропсами в React?](#у-чому-різниця-між-станом-і-пропсами-в-react?) |
| 11 | [Як обробляти події в React?](#як-обробляти-події-в-react?) |
| 12 | [Що таке умовний рендеринг у React?](#що-таке-умовний-рендеринг-у-react?) |
| 13 | [Як передати дані між компонентами вгору і вниз за ієрархією?](#як-передати-дані-між-компонентами-вгору-і-вниз-за-ієрархією?) |
| 14 | [Как выполнить HTTP-запросы в React?](#как-выполнить-http-запросы-в-react?) |
| 15 | [Що таке контекст (context) у React і для чого він використовується?](#що-таке-контекст-(context)-у-react-і-для-чого-він-використовується?) |
| 16 | [Як реалізувати PureComponent?](#як-реалізувати-purecomponent?) |
| 17 | [Що таке ключі (keys) у списках React-елементів і навіщо вони потрібні?](#що-таке-ключі-(keys)-у-списках-react-елементів-і-навіщо-вони-потрібні?) |
| 18 | [Як використовувати стилі в React-компонентах?](#як-використовувати-стилі-в-react-компонентах?) |
| 19 | [Що таке «керовані компоненти» (controlled components)?](#що-таке-«керовані-компоненти»-(controlled-components)?) |
| 20 | [Що таке «некеровані компоненти» (uncontrolled components)?](#що-таке-«некеровані-компоненти»-(uncontrolled-components)?) |
| 21 | [Що таке «підйом стану» (lifting state up)?](#що-таке-«підйом-стану»-(lifting-state-up)?) |
| 22 | [Як створити форму в React?](#як-створити-форму-в-react?) |
| 23 | [Як реалізувати умовне додавання класу до елемента в React?](#як-реалізувати-умовне-додавання-класу-до-елемента-в-react?) |
| 24 | [Що таке фрагменти (fragments) у React?](#що-таке-фрагменти-(fragments)-у-react?) |
| 25 | [Яким чином можна оптимізувати продуктивність React-додатку?](#яким-чином-можна-оптимізувати-продуктивність-react-додатку?) |
| 26 | [Що таке HOC (Higher-Order Component) у React?](#що-таке-hoc-(higher-order-component)-у-react?) |
| 27 | [В чем разница между HOC и компонентами с рендер-пропсами (render props)?](#в-чем-разница-между-hoc-и-компонентами-с-рендер-пропсами-(render-props)?) |
| 28 | [Что такое рефы (refs) в React и как они используются?](#что-такое-рефы-(refs)-в-react-и-как-они-используются?) |
| 29 | [Як реалізувати анімацію в React-додатку?](#як-реалізувати-анімацію-в-react-додатку?) |
| 30 | [Як працює механізм "контексту" (context) для передачі даних?](#як-працює-механізм-"контексту"-(context)-для-передачі-даних?) |
| 31 | [Що таке портали (portals) у React?](#що-таке-портали-(portals)-у-react?) |
| 32 | [Як реалізувати lazy loading у React з використанням Suspense?](#як-реалізувати-lazy-loading-у-react-з-використанням-suspense?) |
| 33 | [Які нововведення було додано в React 16?](#які-нововведення-було-додано-в-react-16?) |
| 34 | [Як використовувати React DevTools для налагодження програми?](#як-використовувати-react-devtools-для-налагодження-програми?) |
| 35 | [Що таке "хуки" (hooks) у React і для чого вони використовуються?](#що-таке-"хуки"-(hooks)-у-react-і-для-чого-вони-використовуються?) |
| 36 | [Як створити власний хук у React?](#як-створити-власний-хук-у-react?) |
| 37 | [Як обробляти помилки в React-додатку за допомогою Error Boundary?](#як-обробляти-помилки-в-react-додатку-за-допомогою-error-boundary?) |
| 38 | [Як працює алгоритм узгодження (reconciliation) у React?](#як-працює-алгоритм-узгодження-(reconciliation)-у-react?) |
| 39 | [Які популярні бібліотеки для управління станом ви знаєте, крім вбудованого `useState`?](#які-популярні-бібліотеки-для-управління-станом-ви-знаєте,-крім-вбудованого-`usestate`?) |
| 40 | [Каким образом можно оптимизировать рендеринг компонентов в React?](#каким-образом-можно-оптимизировать-рендеринг-компонентов-в-react?) |
| 41 | [Що таке "глибоке порівняння" (deep comparison) у контексті оптимізації продуктивності React?](#що-таке-"глибоке-порівняння"-(deep-comparison)-у-контексті-оптимізації-продуктивності-react?) |
| 42 | [Як використовувати memoization для оптимізації компонентів?](#як-використовувати-memoization-для-оптимізації-компонентів?) |
| 43 | [Які патерни використання Redux ви знаєте?](#які-патерни-використання-redux-ви-знаєте?) |
| 44 | [Як працює бібліотека React Router?](#як-працює-бібліотека-react-router?) |
| 45 | [Що таке SSR (Server-Side Rendering) і як він відрізняється від CSR (Client-Side Rendering)?](#що-таке-ssr-(server-side-rendering)-і-як-він-відрізняється-від-csr-(client-side-rendering)?) |
| 46 | [Як реалізувати асинхронне завантаження компонентів за допомогою React Router?](#як-реалізувати-асинхронне-завантаження-компонентів-за-допомогою-react-router?) |
| 47 | [Які переваги дає використання Redux для управління станом застосунку:](#які-переваги-дає-використання-redux-для-управління-станом-застосунку:) |
| 48 | [Що таке Redux Thunk?](#що-таке-redux-thunk?) |
| 49 | [Як працює Redux Saga?](#як-працює-redux-saga?) |
| 50 | [Як реалізувати ледаче завантаження Redux-редьюсерів?](#як-реалізувати-ледаче-завантаження-redux-редьюсерів?) |
| 51 | [Що таке "нормалізація стану" (state normalization) у контексті керування станом програми?](#що-таке-"нормалізація-стану"-(state-normalization)-у-контексті-керування-станом-програми?) |
| 52 | [Як створити анімований перехід між сторінками за допомогою React Router?](#як-створити-анімований-перехід-між-сторінками-за-допомогою-react-router?) |
| 53 | [Як працюють CSS-модулі (CSS Modules) у React?](#як-працюють-css-модулі-(css-modules)-у-react?) |
| 54 | [Що таке Styled Components, і як воно використовується?](#що-таке-styled-components,-і-як-воно-використовується?) |
| 55 | [Як передати дані з сервера на клієнт під час використання SSR у React?](#як-передати-дані-з-сервера-на-клієнт-під-час-використання-ssr-у-react?) |
| 56 | [Які переваги та недоліки мають функціональні компоненти порівняно з компонентами класів?](#які-переваги-та-недоліки-мають-функціональні-компоненти-порівняно-з-компонентами-класів?) |
| 57 | [Які особливості мають хуки `useEffect` та `useLayoutEffect`?](#які-особливості-мають-хуки-`useeffect`-та-`uselayouteffect`?) |
| 58 | [Як оновити стан компонента після виконання асинхронної операції?](#як-оновити-стан-компонента-після-виконання-асинхронної-операції?) |
| 59 | [Що таке CSS-in-JS, і які бібліотеки ви знаєте для реалізації цієї концепції в React?](#що-таке-css-in-js,-і-які-бібліотеки-ви-знаєте-для-реалізації-цієї-концепції-в-react?) |
| 60 | [Як реалізувати drag-and-drop функціональність у React-додатку?](#як-реалізувати-drag-and-drop-функціональність-у-react-додатку?) |
| 61 | [Як реалізувати аутентифікацію та авторизацію в React-додатку?](#як-реалізувати-аутентифікацію-та-авторизацію-в-react-додатку?) |
| 62 | [Як працює маршрутизація на стороні клієнта в React?](#як-працює-маршрутизація-на-стороні-клієнта-в-react?) |
| 63 | [Что такое "code splitting" (разделение кода) в React?](#что-такое-"code-splitting"-(разделение-кода)-в-react?) |
| 64 | [Как управлять состоянием между компонентами, не имеющими близкой связи?](#как-управлять-состоянием-между-компонентами,-не-имеющими-близкой-связи?) |
| 65 | [Які засоби надає React для тестування компонентів?](#які-засоби-надає-react-для-тестування-компонентів?) |
| 66 | [Як працює "ледаче завантаження" (lazy loading) компонентів у React?](#як-працює-"ледаче-завантаження"-(lazy-loading)-компонентів-у-react?) |
| 67 | [Що таке "синтетичні події" (synthetic events) у React?](#що-таке-"синтетичні-події"-(synthetic-events)-у-react?) |
| 68 | [Як організувати перевикористання компонентів у React?](#як-організувати-перевикористання-компонентів-у-react?) |
| 69 | [Що таке "високонавантажені компоненти" (high-order components) і як їх створити?](#що-таке-"високонавантажені-компоненти"-(high-order-components)-і-як-їх-створити?) |
| 70 | [Какие принципы следует соблюдать при именовании компонентов в React?](#какие-принципы-следует-соблюдать-при-именовании-компонентов-в-react?) |
| 71 | [Як реалізувати анімацію переходів між компонентами в React Router?](#як-реалізувати-анімацію-переходів-між-компонентами-в-react-router?) |
| 72 | [Що таке "глибоке перенесення стану" (deep state transfer) у React?](#що-таке-"глибоке-перенесення-стану"-(deep-state-transfer)-у-react?) |
| 73 | [Як реалізувати модальне вікно в React-додатку?](#як-реалізувати-модальне-вікно-в-react-додатку?) |
| 74 | [Що таке SSR (Server-Side Rendering) і навіщо його використовувати?](#що-таке-ssr-(server-side-rendering)-і-навіщо-його-використовувати?) |
| 75 | [Які переваги дає використання CSS-модулів (CSS Modules)?](#які-переваги-дає-використання-css-модулів-(css-modules)?) |
| 76 | [Що таке "віртуалізація списку" (list virtualization) і як вона реалізується в React?](#що-таке-"віртуалізація-списку"-(list-virtualization)-і-як-вона-реалізується-в-react?) |
| 77 | [Як реалізувати include компонентів у React?](#як-реалізувати-include-компонентів-у-react?) |
| 78 | [Що таке "консиліація" (reconciliation) у контексті React?](#що-таке-"консиліація"-(reconciliation)-у-контексті-react?) |
| 79 | [Як обробляти форми в React?](#як-обробляти-форми-в-react?) |
| 80 | [Альтернативи Redux для керування станом у React-додатках](#альтернативи-redux-для-керування-станом-у-react-додатках) |
| 81 | [Як працює «гаряча заміна модулів» (Hot Module Replacement) у середовищі розробки React-додатків?](#як-працює-«гаряча-заміна-модулів»-(hot-module-replacement)-у-середовищі-розробки-react-додатків?) |
| 82 | [Що таке «мемоізація» (memoization) і як вона може бути застосована в React?](#що-таке-«мемоізація»-(memoization)-і-як-вона-може-бути-застосована-в-react?) |
| 83 | [Як реалізувати зв'язування даних (data binding) у React?](#як-реалізувати-зв'язування-даних-(data-binding)-у-react?) |
| 84 | [Що таке «передача даних через контекст» (context passing) у React?](#що-таке-«передача-даних-через-контекст»-(context-passing)-у-react?) |
| 85 | [Як реалізувати перетягування (drag-and-drop) елементів у React-додатку?](#як-реалізувати-перетягування-(drag-and-drop)-елементів-у-react-додатку?) |
| 86 | [Що таке «обчислювані властивості» (computed properties) у контексті React?](#що-таке-«обчислювані-властивості»-(computed-properties)-у-контексті-react?) |
| 87 | [Як реалізувати «ледаче завантаження» (lazy loading) зображень у React?](#як-реалізувати-«ледаче-завантаження»-(lazy-loading)-зображень-у-react?) |
| 88 | [Що таке «рендер-пропси» (render props) і як вони використовуються?](#що-таке-«рендер-пропси»-(render-props)-і-як-вони-використовуються?) |
| 89 | [Як працює «ледаче завантаження» (lazy loading) сторонніх бібліотек у React?](#як-працює-«ледаче-завантаження»-(lazy-loading)-сторонніх-бібліотек-у-react?) |
| 90 | [Що таке «реактивне програмування» (reactive programming) у контексті React?](#що-таке-«реактивне-програмування»-(reactive-programming)-у-контексті-react?) |
| 91 | [Як обробляти помилки під час використання хуків (hooks) у React?](#як-обробляти-помилки-під-час-використання-хуків-(hooks)-у-react?) |
| 92 | [Що таке «інкапсуляція стану» (state encapsulation) у React?](#що-таке-«інкапсуляція-стану»-(state-encapsulation)-у-react?) |
| 93 | [Як реалізувати анімований перехід між компонентами в React Native?](#як-реалізувати-анімований-перехід-між-компонентами-в-react-native?) |
| 94 | [Що таке «стабільні ідентифікатори» (stable keys) і навіщо вони потрібні в React?](#що-таке-«стабільні-ідентифікатори»-(stable-keys)-і-навіщо-вони-потрібні-в-react?) |
| 95 | [Як оновити стан компонента після зміни props?](#як-оновити-стан-компонента-після-зміни-props?) |
| 96 | [Що таке «компоненти вищого порядку» (Higher-Order Components, HOC) у React?](#що-таке-«компоненти-вищого-порядку»-(higher-order-components,-hoc)-у-react?) |
| 97 | [Які є патерни для роботи з асинхронністю в React?](#які-є-патерни-для-роботи-з-асинхронністю-в-react?) |
| 98 | [Що таке «реактивний потік даних» (reactive data flow) у контексті React?](#що-таке-«реактивний-потік-даних»-(reactive-data-flow)-у-контексті-react?) |
## Що таке React?
[⬆ Повернутися до списку](#список-запитань)

**React** - це бібліотека JavaScript, розроблена компанією Facebook, яка використовується для створення користувацьких інтерфейсів.

Вона дає змогу розбивати призначений для користувача інтерфейс на невеликі компоненти, які можуть оновлюватися незалежно один від одного, що забезпечує ефективне управління станом і оновленнями на веб-сторінці.

React використовує віртуальне DOM (Document Object Model) для оптимізації продуктивності, даючи змогу ефективно оновлювати тільки частини інтерфейсу, що змінилися.

Однією з головних концепцій React є "односпрямований потік даних", що полегшує відстеження змін і управління станом програми. React широко використовується в розробці веб-додатків і мобільних додатків з використанням фреймворка React Native.

## Які основні переваги використання React?
[⬆ Повернутися до списку](#список-запитань)

Використання React має кілька ключових переваг:

1. Віртуальний DOM: React використовує віртуальний DOM для ефективного управління оновленнями інтерфейсу. Це дає змогу мінімізувати операції безпосередньо з реальним DOM, що підвищує продуктивність програми.

2. Компонентний підхід: React дає змогу розбивати користувацький інтерфейс на безліч дрібних компонентів. Ці компоненти можуть бути повторно використані, що спрощує розробку, тестування та обслуговування коду.

3. Односпрямований потік даних: React забезпечує односпрямований потік даних, що спрощує відстеження змін стану і робить код більш передбачуваним і легко підтримуваним.

4. Оголошувальний підхід: React використовує оголошувальний стиль програмування, який дає змогу описувати, який вигляд має мати інтерфейс залежно від стану. Це робить код більш читабельним і зрозумілим.

5. Екосистема і співтовариство: React має велику й активну спільноту розробників, що забезпечує безліч готових рішень, бібліотек та інструментів для розробки.

6. React Native: Для розробки мобільних додатків можна використовувати React Native, який дає змогу використовувати React для створення нативних мобільних додатків під різні платформи.

7. Висока продуктивність: Завдяки віртуальному DOM і оптимізаціям, React здатний забезпечувати хорошу продуктивність навіть під час роботи з великими і складними інтерфейсами.

## Що таке JSX?
[⬆ Повернутися до списку](#список-запитань)

**JSX** (JavaScript XML) - це розширення синтаксису JavaScript, що використовується в React для опису структури користувацького інтерфейсу.

Цей синтаксис дає змогу об'єднувати код JavaScript і HTML-подібні елементи в одному місці, що робить створення компонентів React більш інтуїтивним і читабельним.

JSX дає змогу вставляти JavaScript-вирази всередині тегів, укладаючи їх у фігурні дужки. Наприклад:

```
const name = "Микола";
const element = <h1>Привіт, {name}</h1>;
```

У цьому прикладі змінна name вставлена всередині JSX-елемента за допомогою фігурних дужок.

JSX також дає змогу описувати користувацькі компоненти користувача у вигляді елементів, що робить код більш структурованим і зручним для читання:

```
function Greeting(props) {
  return <p>Привіт, {props.name}!</p>;
}
```

JSX-код потрібно перетворити на звичайний JavaScript-код перед тим, як він буде виконаний у браузері. Для цього використовуються інструменти компіляції, зазвичай включені в складальний процес проекту на React.

## Які основні відмінності між компонентами класів і функціональними компонентами в React?
[⬆ Повернутися до списку](#список-запитань)

У React існують два основні способи створення компонентів: з використанням класів і з використанням функціональних компонентів. Ось основні відмінності між ними:

### Компоненти класів:

1. Синтаксис: Компоненти класів визначаються як класи, що розширюють базовий клас React.Component.

2. Стан (state): Компоненти класів мають вбудовану підтримку для стану (state), що дає їм змогу зберігати та керувати даними всередині компонента.

3. Методи життєвого циклу: Компоненти класів мають широкий набір методів життєвого циклу (наприклад, componentDidMount, componentDidUpdate, componentWillUnmount), які дають змогу реагувати на різні етапи життя компонента.

4. Пропси (props): Пропси передаються в компоненти класів через атрибути під час використання. Вони доступні через this.props всередині методів компонента.

### Функціональні компоненти:

1. Синтаксис: Функціональні компоненти визначаються як звичайні функції.

2. Стан (state): Спочатку функціональні компоненти не підтримували стан. Однак із появою хуків (hooks) у React (починаючи з React 16.8) функціональні компоненти тепер можуть використовувати стан та інші можливості, що раніше були доступні тільки компонентам класів.

3. Хуки (hooks): Функціональні компоненти можуть використовувати хуки, як-от useState, useEffect та інші, для керування станом, ефектами та іншими аспектами.

4. Пропси (props): Пропси також передаються функціональним компонентам, але доступні вони як аргументи функції.

Загалом, з появою хуків, функціональні компоненти стали кращим вибором для більшості випадків у React, оскільки вони забезпечують простіший синтаксис, який можна прочитати, а також спрощений спосіб керування станом і ефектами.

## Що таке Virtual DOM, та як він працює?
[⬆ Повернутися до списку](#список-запитань)

Virtual DOM (віртуальне DOM) - це концепція, яку використовують у бібліотеках і фреймворках, як-от React, для оптимізації оновлень реального DOM (Document Object Model) і підвищення продуктивності веб-додатків.

Реальний DOM - це представлення структури веб-сторінки в браузері у вигляді дерева об'єктів. Коли стан програми змінюється і потрібне оновлення інтерфейсу, браузер виконує зміни безпосередньо в реальному DOM. Однак багаторазові та часті оновлення реального DOM можуть бути витратними з погляду продуктивності, особливо для великих і складних інтерфейсів.

Віртуальний DOM розв'язує цю проблему таким чином:

1. Створення віртуального DOM: Під час зміни стану застосунку React створює віртуальне представлення DOM-структури, яка є легковажною копією реального DOM.

2. Порівняння віртуального DOM: React порівнює попередній стан віртуального DOM із новим станом, виявляючи, які частини інтерфейсу було змінено.

3. Генерація різниці (патч): На основі порівняння React створює мінімальний набір змін, необхідних для оновлення віртуального DOM згідно з новим станом.

4. Застосування змін: Створені зміни застосовуються до реального DOM тільки одним оновленням, що дає змогу уникнути множинних маніпуляцій із реальним DOM.

Використання віртуального DOM дає змогу значно поліпшити продуктивність, оскільки оновлення реального DOM відбуваються тільки в необхідних місцях. Це також робить розробку більш зручною і передбачуваною, оскільки розробнику не потрібно вручну керувати безліччю змін на реальному DOM.

## Які методи життєвого циклу компонентів ви знаєте?
[⬆ Повернутися до списку](#список-запитань)

У React компоненти проходять через низку етапів свого "життєвого циклу", включно з такими методами:

1. **constructor(props)**: Викликається під час створення компонента. Тут відбувається ініціалізація стану і прив'язка методів.

2. **componentDidMount()**: Викликається після того, як компонент було вставлено в DOM. Часто використовується для завантаження даних із сервера.

3. **componentDidUpdate(prevProps, prevState)**: Викликається після оновлення компонента. Дозволяє реагувати на зміни пропсів або стану.

4. **shouldComponentUpdate(nextProps, nextState)**: Дозволяє оптимізувати оновлення компонента, повертаючи false, якщо оновлення не потрібне.

5. **componentWillUnmount()**: Викликається перед видаленням компонента з DOM. Використовується для очищення ресурсів.

6. **static getDerivedStateFromProps(props, state)**: Рідко використовується. Дозволяє оновити стан на основі нових пропсів.

7. **getSnapshotBeforeUpdate(prevProps, prevState)**: Рідко використовується. Дозволяє отримати інформацію з DOM перед його оновленням.

8. **componentDidCatch(error, info)**: Використовується для обробки помилок у дочірніх компонентах.

Це лише короткий огляд методів життєвого циклу компонентів у React.

## Що таке "стан" (state) компонента в React?
[⬆ Повернутися до списку](#список-запитань)

"Стан" (state) у React є об'єктом, який містить дані, що впливають на те, як компонент відображається і поводиться. Стан є одним із фундаментальних понять React і використовується для зберігання інформації, яка може змінюватися під час роботи програми.

Коли стан компонента змінюється, React автоматично перерендерує компонент, щоб відобразити новий стан. Стан зазвичай ініціалізується в методі constructor() компонента, і для його оновлення використовується метод setState().

Приклад:

```
import React, { Component } from "react";

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0, // Початковий стан
    };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Счетчик: {this.state.count}</p>
        <button onClick={this.increment}>Збільшити</button>
      </div>
    );
  }
}

export default Counter;
```

У цьому прикладі компонент Counter має стан count, який оновлюється при кліці на кнопку. Під час виклику setState(), React оновить стан і перерендерить компонент, відображаючи нове значення count.

## Як оновити стан компонента?
[⬆ Повернутися до списку](#список-запитань)

У React для оновлення стану компонента слід використовувати метод setState(). Цей метод приймає або об'єкт з оновленнями стану, або функцію, яка повертає об'єкт з оновленнями. Під час виклику setState(), React оновить стан компонента і перерендерує його, щоб відобразити новий стан.

Приклад використання setState():

```
import React, { Component } from "react";

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
    };
  }

  increment = () => {
    //  Оновлення стану з використанням об'єкта
    this.setState({ count: this.state.count + 1 });
  };

  decrement = () => {
    // Оновлення стану з використанням функції
    this.setState((prevState) => {
      return { count: prevState.count - 1 };
    });
  };

  render() {
    return (
      <div>
        <p>Счетчик: {this.state.count}</p>
        <button onClick={this.increment}>Збільшити</button>
        <button onClick={this.decrement}>Зменшити</button>
      </div>
    );
  }
}

export default Counter;
```

У цьому прикладі increment() і decrement() оновлюють стан count за допомогою setState(). Важливо використовувати функції під час оновлення стану, особливо якщо новий стан залежить від попереднього стану, щоб уникнути проблем з асинхронністю.

## Что такое пропсы (props) в React?
[⬆ Повернутися до списку](#список-запитань)

"Пропси" (props) у React - це механізм передачі даних від батьківського компонента до дочірнього. Вони являють собою атрибути, які задаються при створенні компонента і не можуть бути змінені самим компонентом, який їх отримує. Пропси використовуються для передачі інформації про стан або конфігурацію компонента.

Приклад використання пропсів:

```
import React from "react";

function Welcome(props) {
  return <h1>Вітаю, {props.name}!</h1>;
}

const App = () => {
  return <Welcome name="Ірина" />;
};

export default App;
```

У цьому прикладі компонент **Welcome** приймає пропс **name** і використовує його для виведення персоналізованого привітання. Компонент **App** передає значення "Ірина" в пропс **name** компонента **Welcome**.

Пропси передаються у вигляді об'єкта і доступні як властивості (**props**) всередині дочірнього компонента.

Використання пропсів дає змогу створювати більш гнучкі та перевикористовувані компоненти, адже можна налаштовувати їхню поведінку та відображення ззовні.

## У чому різниця між станом і пропсами в React?
[⬆ Повернутися до списку](#список-запитань)

Стан (**state**) і пропси (**props**) - це два основні концепти в React, які використовуються для управління даними в компонентах. Вони мають різні цілі та характеристики:

#### Стан (state):

1. Стан - це внутрішні дані компонента, які можуть змінюватися під час виконання.
2. Визначається та керується самим компонентом, у якому він знаходиться.
3. Зміна стану викликає перерендеринг компонента, щоб відобразити новий стан.
4. Доступно тільки для компонента, у якому було визначено стан.
5. Оновлюється з використанням методу setState().

#### Пропсы (props):

1. Пропси - це дані, що передаються від батьківського компонента до дочірнього компонента.
2. Не можна змінити пропси всередині дочірнього компонента. Вони вважаються "тільки для читання".
3. Пропси слугують для налаштування та передавання даних у компоненти.
4. Використовуються для зв'язку між різними компонентами і передавання інформації вниз по ієрархії.
5. Не спричиняють перерендерінг у разі їхньої зміни.

Коротко кажучи, стан призначений для зберігання і управління даними, що змінюються всередині компонента, тоді як пропси призначені для передачі даних від батьківського компонента до дочірнього. Обидва ці концепти допомагають створювати динамічні та перевикористовувані інтерфейси в React додатках.

## Як обробляти події в React?
[⬆ Повернутися до списку](#список-запитань)

У React обробка подій відбувається з використанням синтаксису, аналогічного обробці подій у нативному JavaScript, але з деякими відмінностями. Ось як обробляти події в React:

1. Створення методу обробки події: Створіть метод усередині компонента, який буде виконуватися при виникненні події. Назва методу зазвичай починається з префікса "handle", за яким слідує ім'я події або описове ім'я.

2. Прив'язка методу до елемента: Прив'яжіть створений метод до елемента, який генеруватиме подію. Це робиться за допомогою JSX, вказавши метод як значення атрибута події.

3. Використання аргументів: Усередині методу обробки події ви можете отримати доступ до об'єкта події та використовувати його властивості, такі як `target`, щоб отримати інформацію про подію.

Приклад обробки кліка:

```
import React, { Component } from "react";

class Button extends Component {
  handleClick = () => {
    console.log("Кнопка була натиснута");
  };

  render() {
    return <button onClick={this.handleClick}>Натисни на мене</button>;
  }
}

export default Button;
```

В этом примере метод `handleClick` вызывается при клике на кнопку, выводя сообщение в консоль.

Важно заметить, что при передаче метода обработки события в качестве атрибута JSX, не следует вызывать его с помощью круглых скобок (например, не пишите `onClick={this.handleClick()}`), так как это вызовет выполнение метода сразу при рендеринге.

## Що таке умовний рендеринг у React?
[⬆ Повернутися до списку](#список-запитань)

Умовний рендеринг у React - це підхід, за якого вирішується, чи повинен компонент або його частина відображатися на основі будь-якої умови. Це дає змогу динамічно контролювати, які елементи інтерфейсу будуть показані або приховані залежно від стану застосунку або інших чинників.

Приклад умовного рендерингу:

```
import React, { Component } from "react";

class Greeting extends Component {
  render() {
    const isLoggedIn = this.props.isLoggedIn;

    if (isLoggedIn) {
      return <h1>Вітаємо вас на нашому сайті!</h1>;
    } else {
      return <h1>Будь ласка, увійдіть до системи!</h1>;
    }
  }
}

export default Greeting;
```

У цьому прикладі компонент Greeting залежно від значення пропса isLoggedIn рендерить різні заголовки. Якщо isLoggedIn дорівнює true, відображається привітання, в іншому разі - запрошення до входу в систему.

Умовний рендеринг можна реалізувати також за допомогою тернарного оператора:

```
class Greeting extends Component {
  render() {
    const isLoggedIn = this.props.isLoggedIn;

    return (
      <div>
        {isLoggedIn ? (
          <h1>Привіт, Сергій!</h1>
        ) : (
          <h1>Будь ласка, авторизуйтеся на сайті.</h1>
        )}
      </div>
    );
  }
}
```

Умовний рендеринг особливо корисний, коли потрібно адаптувати інтерфейс на основі динамічних даних або станів, таких як авторизація користувача, наявність даних та інші умови.

## Як передати дані між компонентами вгору і вниз за ієрархією?
[⬆ Повернутися до списку](#список-запитань)

У React дані можуть передаватися між компонентами вгору і вниз по ієрархії з використанням пропсів (props) і колбеків (callback функцій). Ось як це працює:

#### Передача даних вниз за ієрархією (від батька до дочірнього компонента):

Пропси (props): Батьківський компонент передає дані своєму дочірньому компоненту через пропси. Дочірній компонент може отримати доступ до цих даних як властивості (props).

Приклад:

```
// Батьківський компонент
import React from "react";
import ChildComponent from "./ChildComponent";

const ParentComponent = () => {
  const data = "Дані для дочірнього компонента";

  return <ChildComponent dataProp={data} />;
};

// Дочірній компонент
import React from "react";

const ChildComponent = (props) => {
  return <p>{props.dataProp}</p>;
};

export default ChildComponent;
```

#### Передавання даних вгору за ієрархією (від дочірнього компонента до батька):

Колбеки (callback функції): Батьківський компонент передає функцію як пропса дочірньому компоненту. Дочірній компонент може викликати цю функцію, передаючи їй дані назад вгору по ієрархії.

Приклад:

```
// Батьківський компонент
import React, { useState } from "react";
import ChildComponent from "./ChildComponent";

const ParentComponent = () => {
  const [receivedData, setReceivedData] = useState("");

  const handleDataChange = (data) => {
    setReceivedData(data);
  };

  return (
    <div>
      <p>Отримані дані: {receivedData}</p>
      <ChildComponent onDataChange={handleDataChange} />
    </div>
  );
};

// Дочірній компонент
import React from "react";

const ChildComponent = (props) => {
  const sendDataToParent = () => {
    props.onDataChange("Дані від дочірнього компонента");
  };

  return <button onClick={sendDataToParent}>Надіслати дані</button>;
};

export default ChildComponent;
```

Це дає змогу дочірньому компоненту впливати на дані та стан батьківського компонента.

Використовуючи цей підхід, ви можете ефективно передавати й оновлювати дані між компонентами вгору і вниз по ієрархії.

## Как выполнить HTTP-запросы в React?
[⬆ Повернутися до списку](#список-запитань)

Для выполнения HTTP-запросов в React обычно используются библиотеки, такие как axios или встроенный fetch. Вот как выполнить GET-запрос с использованием библиотеки axios:

1. Установите библиотеку axios с помощью npm или yarn:

```
npm install axios
```

або

```
yarn add axios
```

2. У компоненті, де ви хочете виконати HTTP-запит:

```
import React, { useState, useEffect } from "react";
import axios from "axios";

const DataFetching = () => {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    axios
      .get("https://api.example.com/data")
      .then((response) => {
        setData(response.data);
        setIsLoading(false);
      })
      .catch((error) => {
        setError(error.message);
        setIsLoading(false);
      });
  }, []); // Порожній масив залежностей, щоб запит виконався тільки один раз

  if (isLoading) {
    return <p>Завантаження...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>Fetched Data</h2>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
};

export default DataFetching;
```

У цьому прикладі ми використовуємо хук useState для управління станом даних, завантаження і помилок. Хук useEffect використовується для виконання HTTP-запиту під час монтування компонента. Залежно від результату запиту, ми оновлюємо стан для відображення даних, завантаження або помилки.

## Що таке контекст (context) у React і для чого він використовується?
[⬆ Повернутися до списку](#список-запитань)

Контекст (context) у React - це механізм, який дає змогу передавати дані глибоко вниз по ієрархії компонентів, минаючи пропси (props). Він використовується, коли певні дані потрібні в безлічі компонентів, і передача через кожен компонент стає незручною.

Контекст дає змогу створити «контекстне» оточення, в якому компоненти можуть отримувати доступ до даних без необхідності явно передавати їх через пропси. Це особливо корисно для глобальних даних, таких як дані автентифікації, теми оформлення та інші загальні стани.

Для створення контексту використовуються два елементи: провайдер (Provider) і споживач (Consumer).

Приклад використання контексту:

```
import React, { createContext, useContext } from "react";

// Створюємо контекст
const UserContext = createContext();

// Компонент, який постачає дані
const UserProvider = ({ children }) => {
  const user = { name: "Serhii", role: "developer" };

  return <UserContext.Provider value={user}>{children}</UserContext.Provider>;
};

// Компонент, що використовує контекст
const UserInfo = () => {
  const user = useContext(UserContext);

  return (
    <div>
      <p>Name: {user.name}</p>
      <p>Role: {user.role}</p>
    </div>
  );
};

// Головний компонент, який обертає додаток у провайдер даних
const App = () => {
  return (
    <UserProvider>
      <UserInfo />
    </UserProvider>
  );
};

export default App;
```

У цьому прикладі контекст UserContext використовується для передачі інформації про користувача від UserProvider до UserInfo, минаючи пропси. Компонент UserInfo використовує хук useContext, щоб отримати доступ до даних контексту.

Контекст слід використовувати обережно і тільки там, де це справді необхідно, оскільки це може ускладнити розуміння взаємодії компонентів і ускладнити налагодження.

## Як реалізувати PureComponent?
[⬆ Повернутися до списку](#список-запитань)

Щоб створити **PureComponent** у React, ви можете використовувати класи або функціональні компоненти з хуками.

1. З використанням класів:

```
import React, { PureComponent } from "react";

class MyPureComponent extends PureComponent {
  render() {
    return <div>{/* Код компоненту */}</div>;
  }
}

export default MyPureComponent;
```

2. З використанням функціональних компонентів і хуків:

```
import React, { memo } from "react";

const MyPureComponent = () => {
  return <div>{/* Код компоненту */}</div>;
};

export default memo(MyPureComponent);
```

Обидва варіанти **PureComponent** автоматично порівнюють пропси і стан, і перемальовують компонент тільки в разі змін даних. Це може істотно поліпшити продуктивність, уникаючи непотрібних перемальовок.

## Що таке ключі (keys) у списках React-елементів і навіщо вони потрібні?
[⬆ Повернутися до списку](#список-запитань)

У React, ключі (keys) - це спеціальні атрибути, які використовуються під час рендерингу списків компонентів або елементів. Вони допомагають React оптимізувати процес оновлення та перемальовування компонентів у списках.

Ключі призначаються кожному елементу в списку і мають бути унікальними серед своїх сусідніх елементів. Коли React оновлює список компонентів, він використовує ключі для визначення, які елементи були додані, видалені або змінені. Без ключів React буде перемальовувати і оновлювати всі елементи в списку, що може призвести до погіршення продуктивності.

Приклад використання ключів:

```
import React from "react";

const TodoList = ({ data }) => {
  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
};

export default TodoList;
```

У цьому прикладі кожному елементу списку завдань (todo) присвоюється унікальний ключ (todo.id). Це дає змогу React ефективно оновлювати тільки змінені елементи, мінімізуючи кількість перемальовок.

Ключі особливо важливі під час роботи зі списками, які можуть змінюватися в часі, наприклад, під час додавання, видалення або переупорядкування елементів.

## Як використовувати стилі в React-компонентах?
[⬆ Повернутися до списку](#список-запитань)

У React для стилізації компонентів можна використовувати кілька підходів: вбудовані стилі (inline styles), стилі з використанням CSS-класів і бібліотеки стилів. Ось як це робиться:

#### 1. Вбудовані стилі (Inline Styles):

Вбудовані стилі являють собою об'єкт JavaScript, де ключі - це назви CSS-властивостей, а значення - відповідні значення властивостей.

```
import React from "react";

const MyComponent = () => {
  const styles = {
    backgroundColor: "blue",
    color: "yellow",
    padding: "12px",
    borderRadius: "20px",
  };

  return <div style={styles}>Стилізований компонент</div>;
};

export default MyComponent;
```

#### 2. Стилі з використанням CSS-класів:

Ви можете визначити CSS-класи в окремих файлах і додати їх до елементів у компонентах.

```
// styles.css
.myClass {
  background-color: blue;
  color: yellow;
  padding: 12px;
  border-radius: 20px;
}

// MyComponent.jsx
import React from 'react';
import './styles.css';

const MyComponent = () => {
  return <div className="myClass">Стилізований компонент</div>;
};

export default MyComponent;
```

#### 3. Бібліотеки стилів:

Існує безліч бібліотек для стилізації React-компонентів, таких як Styled Components, Emotion, CSS Modules та інші. Ці бібліотеки надають синтаксис для створення компонентів зі стилями всередині коду.

```
// Styled Components
import React from "react";
import styled from "styled-components";

const StyledDiv = styled.div`
  background-color: blue;
  color: yellow;
  padding: 12px;
  border-radius: 20px;
`;

const MyComponent = () => {
  return <StyledDiv>Стилізований компонент</StyledDiv>;
};

export default MyComponent;
```

Вибір методу залежить від уподобань та вимог проєкту. Важливо звернути увагу на підтримку класів, перевикористання стилів і простоту супроводу під час вибору підходу.

## Що таке «керовані компоненти» (controlled components)?
[⬆ Повернутися до списку](#список-запитань)

«Керовані компоненти» (controlled components) - це поняття, пов'язане з управлінням станом форм і введення даних у React. У керованих компонентах значення елемента введення (наприклад, текстового поля або чекбокса) контролюється станом React компонента, а не DOM елементом.

Коли компонент контролює значення введення, він зберігає це значення у своєму стані й оновлює його за допомогою обробників подій (наприклад, у разі зміни тексту в полі введення). Це дає змогу мати повний контроль над даними форми та легко реагувати на зміни.

Приклад керованого компонента з текстовим полем:

```
import React, { useState } from "react";

const ControlledComponent = () => {
  const [inputValue, setInputValue] = useState("");

  const handleInputChange = (event) => {
    setInputValue(event.target.value);
  };

  return (
    <div>
      <input type="text" value={inputValue} onChange={handleInputChange} />
      <p>Введене значення: {inputValue}</p>
    </div>
  );
};

export default ControlledComponent;
```

У цьому прикладі значення текстового поля inputValue пов'язане зі станом компонента. Коли значення текстового поля змінюється, викликається обробник handleInputChange, який оновлює стан і, отже, значення текстового поля.

Використання керованих компонентів забезпечує передбачуваність стану, спрощує взаємодію з даними і дає змогу виконувати валідацію та інші операції над введеними даними перед їхнім надсиланням на сервер.

## Що таке «некеровані компоненти» (uncontrolled components)?
[⬆ Повернутися до списку](#список-запитань)

«Некеровані компоненти» (uncontrolled components) - це поняття, протилежне керованим компонентам, і воно відноситься до управління станом форм і введення даних у React. У разі некерованих компонентів, значення елемента введення (наприклад, input або textarea) зберігається безпосередньо в DOM, і React компонент не керує цим значенням.

Замість використання стану компонента для зберігання значення елемента введення, некеровані компоненти звертаються до DOM безпосередньо для отримання та оновлення значення.

Приклад некерованого компонента з текстовим полем:

```
import React, { useRef } from "react";

const UncontrolledComponent = () => {
  const inputRef = useRef(null);

  const handleButtonClick = () => {
    alert("Значення в полі введення: " + inputRef.current.value);
  };

  return (
    <div>
      <input type="text" ref={inputRef} />
      <button onClick={handleButtonClick}>Показати значення</button>
    </div>
  );
};

export default UncontrolledComponent;
```

У цьому прикладі значення текстового поля не зберігається в стані компонента. Натомість ми використовуємо useRef для отримання посилання на DOM-елемент і потім отримуємо його значення через inputRef.current.value.

Некеровані компоненти можуть бути корисними, коли у вас є особливі випадки або вимоги, де контроль над станом через React не є оптимальним підходом. Однак, у більшості випадків, керовані компоненти забезпечують більш передбачуване і зручне управління даними у формах.

## Що таке «підйом стану» (lifting state up)?
[⬆ Повернутися до списку](#список-запитань)

«Підйом стану» (lifting state up) - це патерн у React, який передбачає переміщення стану з дочірніх компонентів до батьківських компонентів, щоб розділяти й керувати станом на вищому рівні та передавати його через пропси.

Цей підхід особливо корисний, коли кілька компонентів повинні мати доступ до одного й того самого стану або коли стан повинен бути синхронізований між різними частинами програми.

Приклад із підйомом стану:

```
import React, { useState } from "react";

const TemperatureInput = ({ scale, temperature, onTemperatureChange }) => {
  return (
    <fieldset>
      <legend>Введіть температуру в градусах {scale}:</legend>
      <input
        value={temperature}
        onChange={(e) => onTemperatureChange(e.target.value)}
      />
    </fieldset>
  );
};

const Calculator = () => {
  const [celsius, setCelsius] = useState("");
  const [fahrenheit, setFahrenheit] = useState("");

  const handleCelsiusChange = (value) => {
    setCelsius(value);
    setFahrenheit((value * 9) / 5 + 32);
  };

  const handleFahrenheitChange = (value) => {
    setFahrenheit(value);
    setCelsius(((value - 32) * 5) / 9);
  };

  return (
    <div>
      <TemperatureInput
        scale="C"
        temperature={celsius}
        onTemperatureChange={handleCelsiusChange}
      />
      <TemperatureInput
        scale="F"
        temperature={fahrenheit}
        onTemperatureChange={handleFahrenheitChange}
      />
    </div>
  );
};

export default Calculator;
```

У цьому прикладі компонент Calculator піднімає стан температур із TemperatureInput компонентів. При зміні температури в одному з вводів, стан піднімається в батьківський компонент Calculator, який потім оновлює стан для іншого вводу, забезпечуючи синхронізацію температур в обох шкалах.

«Підйом стану» допомагає спростити керування даними та їхню синхронізацію між компонентами, особливо під час роботи з компонентами на різних рівнях ієрархії.

## Як створити форму в React?
[⬆ Повернутися до списку](#список-запитань)

Створення форми в React охоплює використання HTML-елементів форми в JSX і управління введенням даних за допомогою стану. Ось як це робиться:

#### Створення компонента форми:

Спочатку створіть компонент форми і визначте елементи форми всередині нього, такі як текстові поля, чекбокси, кнопки тощо.

```
import React, { useState } from "react";

const MyForm = () => {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    // інші поля форми
  });

  const handleInputChange = (event) => {
    const { name, value } = event.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log(formData);
    // відправляємо дані на сервер або виконуємо інші операції
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
          Ім&apos;я:
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={handleInputChange}
        />
      </label>
      <br />
      <label>
        Email:
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleInputChange}
        />
      </label>
      <br />
      {/* Інші поля форми  */}
      <button type="submit">Отправить</button>
    </form>
  );
};

export default MyForm;
```

#### Управління станом:

У цьому прикладі використовується хук useState, щоб керувати станом даних форми. Обробник handleInputChange викликається при зміні полів введення і оновлює стан форми.

#### Обробка надсилання:

Обробник handleSubmit викликається під час надсилання форми. У цьому випадку ми запобігаємо стандартній поведінці надсилання форми на сервер за допомогою event.preventDefault(), щоб продемонструвати обробку даних на клієнті.

#### Прив'язка значень до полів:

Значення полів форми пов'язані зі станом форми. value елементів введення встановлюється рівним значенням зі стану, а при зміні полів викликається обробник handleInputChange.

#### Надсилання даних:

Після заповнення форми і натискання кнопки відправлення, дані можна використовувати для відправлення на сервер, виконання операцій або інших необхідних дій.

## Як реалізувати умовне додавання класу до елемента в React?
[⬆ Повернутися до списку](#список-запитань)

У React ви можете умовно додати клас до елемента, використовуючи тернарний оператор або функцію для визначення класового імені. Ось приклади обох підходів:

#### З використанням тернарного оператора:

```
import React from "react";

const MyComponent = ({ isActive }) => {
  return (
    <div className={isActive ? "active" : "inactive"}>
      Вміст компонента
    </div>
  );
};

export default MyComponent;
```

У цьому прикладі клас active буде додано до елемента, якщо isActive дорівнює true, інакше буде додано клас inactive.

#### З використанням функції для визначення класу:

```
import React from "react";

const MyComponent = ({ isActive }) => {
  const getClassNames = () => {
    return isActive ? "active" : "inactive";
  };

  return <div className={getClassNames()}>Вміст компонента</div>;
};

export default MyComponent;
```

Тут ми визначаємо функцію getClassNames, яка повертає клас залежно від значення isActive.

Якщо ви хочете додати кілька класів, ви можете використовувати об'єднання рядків або бібліотеки, такі як classnames.

```
import React from "react";
import classnames from "classnames";

const MyComponent = ({ isActive, isHighlighted }) => {
  const classNames = classnames({
    active: isActive,
    highlighted: isHighlighted,
  });

  return <div className={classNames}>Вміст компонента</div>;
};

export default MyComponent;
```

У цьому прикладі classnames бібліотека дає змогу додати кілька класів на основі об'єкта, де ключі - це назви класів, а значення - умови, за яких клас буде додано.

## Що таке фрагменти (fragments) у React?
[⬆ Повернутися до списку](#список-запитань)

Фрагменти (fragments) - це механізм у React, який дає змогу вам групувати дочірні елементи без необхідності створювати зайві DOM-елементи. Вони дають змогу повернути кілька елементів із компонента без обертання їх у додатковий DOM-контейнер.

До появи фрагментів, якщо ви хотіли повернути кілька елементів із компонента, вам доводилося обгортати їх у додатковий елемент (наприклад, <div>) або використовувати масив, що могло призвести до зайвого рівня вкладеності або проблем із CSS.

З використанням фрагментів, це має чистіший і ефективніший вигляд:

```
import React from "react";

const MyComponent = () => {
  return (
    <>
      <div>Блок 1</div>
    <div>Блок 2</div>
    </>
  );
};

export default MyComponent;
```

Фрагменти можуть бути оголошені за допомогою порожніх <> і </>, а всередині них ви можете розміщувати будь-яку кількість дочірніх елементів.

Фрагменти особливо корисні, коли вам потрібно повернути кілька елементів з компонента, наприклад, з умовних блоків або маппінгу масивів, і ви хочете уникнути створення додаткових контейнерів у DOM.

## Яким чином можна оптимізувати продуктивність React-додатку?
[⬆ Повернутися до списку](#список-запитань)

Оптимізація продуктивності React-додатку - це важливий аспект, який може суттєво вплинути на користувацький досвід. Ось деякі способи оптимізації продуктивності:

1. Використовуйте керовані компоненти:

Використовуйте керовані компоненти для контролю над даними у формах і введенні. Це дасть змогу мінімізувати непотрібні перемальовування і полегшить обробку введених даних.

2. Використовуйте ключі (keys) правильно:

Під час рендерингу списків компонентів переконайтеся, що в кожного елемента є унікальний ключ. Це дасть змогу React ефективно оновлювати тільки змінені елементи.

3. Ледаче завантаження (Code Splitting):

Розділіть ваш застосунок на невеликі фрагменти і використовуйте механізм ледачого завантаження для завантаження компонентів тільки тоді, коли вони дійсно потрібні.

4. Мемоїзація:

Використовуйте хуки useMemo та useCallback для кешування обчислень і уникнення непотрібних перерахунків під час рендерингу.

5. Пакети компонентів (Component Libraries):

Використовуйте готові пакети компонентів (наприклад, Material-UI, Ant Design), які оптимізовані та протестовані з урахуванням продуктивності.

6. Віртуалізація списків:

Під час роботи з великими списками даних використовуйте бібліотеки віртуалізації (наприклад, react-virtualized), щоб рендерити тільки видимі елементи списку.

7. Оптимізація рендерінгу:

Уникайте непотрібних рендерів компонентів, використовуйте shouldComponentUpdate (у класових компонентах) або React.memo (у функціональних компонентах) для запобігання зайвим перемальовуванням.

8. Уникайте глибокої вкладеності:

Постарайтеся не створювати надто глибоку ієрархію компонентів, щоб зменшити час рендерингу та перерахунку.

9. Аналіз продуктивності:

Використовуйте інструменти, як-от React DevTools та браузерні інструменти продуктивності, щоб аналізувати й оптимізувати продуктивність вашого застосунку.

10. Серверний рендеринг (Server-Side Rendering, SSR):

Якщо це доречно для вашого застосунку, розгляньте можливість використання SSR для поліпшення початкового завантаження та SEO.

Зверніть увагу, що оптимізація продуктивності залежить від конкретного контексту вашого застосунку. Рекомендується використовувати інструменти профілювання та вимірювати продуктивність після кожної оптимізації, щоб переконатися, що вона справді призводить до поліпшень.

## Що таке HOC (Higher-Order Component) у React?
[⬆ Повернутися до списку](#список-запитань)

Високорівневий компонент (Higher-Order Component, HOC) - це патерн у React, який дає змогу повторно використовувати логіку компонентів, абстрагуючи її від самих компонентів. HOC не є частиною API React, це радше патерн композиції компонентів.

HOC - це функція, яка приймає компонент і повертає новий компонент із додатковою логікою. HOC дають змогу винести загальні функціональні або структурні аспекти компонентів і повторно використовувати їх із різними компонентами.

Приклад HOC:

```
import React from "react";

const withLogger = (WrappedComponent) => {
  return class WithLogger extends React.Component {
    componentDidMount() {
      console.log("Рендерінг компонента");
    }

    render() {
      return <WrappedComponent {...this.props} />;
    }
  };
};

const MyComponent = () => {
  return <div>Вміст компонента</div>;
};

const EnhancedComponent = withLogger(MyComponent);

export default EnhancedComponent;
```

У цьому прикладі withLogger - це HOC, який додає логування в метод componentDidMount. Потім компонент MyComponent обгортається HOC, створюючи EnhancedComponent.

HOC дозволяє:

- Розширювати функціональність компонентів без зміни самих компонентів.
- Перевикористовувати код і логіку між різними компонентами.
- Створювати загальні патерни для логування, аутентифікації, обробки помилок та інших аспектів.

Однак, з розвитком React і появою хуків, частина функціональності HOC тепер може бути реалізована з використанням хуків, таких як useEffect, useContext та інших. У більшості випадків, використання хуків є кращим.

## В чем разница между HOC и компонентами с рендер-пропсами (render props)?
[⬆ Повернутися до списку](#список-запитань)

Як HOC (Високорівневий компонент, Higher-Order Component), так і компоненти з рендер-пропсами представляють патерни в React для повторного використання логіки між компонентами. Однак, у них є відмінності в тому, як їх реалізовано і як вони використовуються.

#### HOC (Higher-Order Component):

- HOC - це функція, яка приймає компонент і повертає новий компонент із додатковою логікою.
- HOC можна використовувати як обгортку для компонентів, додаючи до них загальну функціональність.
- HOC виконуються під час створення компонента, і логіка, додана HOC, застосовується під час кожного рендеринга.
- У HOC є доступ до життєвих циклів компонента і його стану.
- Приклад HOC - connect з бібліотеки Redux, який пов'язує компоненти зі сховищем стану.

#### Компоненти з рендер-пропсами (Render Props Components):

- Компонент із рендер-пропсами - це компонент, який приймає функцію як властивість і викликає цю функцію для рендерингу чого-небудь.
- Компонент із рендер-пропсами дає змогу передавати логіку рендерингу безпосередньо в компонент, який використовує цей компонент із рендер-пропсами.
- Логіка рендерингу передається через функцію-пропс і може бути використана за потреби.
- Компонент з рендер-пропсами не має доступу до життєвих циклів батьківського компонента, але може мати доступ до стану через пропси.
- Приклад компонента з рендер-пропсами - компоненти Mouse або Toggle в документації React.

Вибір між HOC і компонентами з рендер-пропсами залежить від конкретної ситуації та вподобань розробника. Обидва патерни дають змогу досягти повторного використання логіки, але з різними підходами.

## Что такое рефы (refs) в React и как они используются?
[⬆ Повернутися до списку](#список-запитань)

Refs (скорочення від references) - це механізм у React, який дає змогу отримувати прямий доступ до DOM-елементів або компонентів, створених у React. Вони дають змогу вам звертатися до елементів, оновлювати їхні властивості та викликати методи компонентів без використання пропсів або стану.

Refs корисні, коли вам потрібно взаємодіяти з DOM елементами безпосередньо або отримувати доступ до методів і властивостей компонентів, які не доступні через пропси.

#### Створення рефів

Існує два способи створення рефів:

1. З використанням `React.createRef()` (class components):

```
import React, { Component } from "react";

class MyComponent extends Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }

  render() {
    return <div ref={this.myRef}>Вміст компоненту</div>;
  }
}
```

2. З використанням колбека (functional components):

```
import React, { useRef } from "react";

const MyComponent = () => {
  const myRef = useRef();

  return <div ref={myRef}>Вміст компоненту</div>;
};
```

#### Використання рефів

Рефи можуть використовуватися для доступу до DOM-елементів або компонентів:

```
class MyComponent extends Component {
  constructor(props) {
    super(props);
    this.myInputRef = React.createRef();
  }

  focusInput() {
    this.myInputRef.current.focus(); // Фокус на input елементі
  }

  render() {
    return <input ref={this.myInputRef} />;
  }
}
```

```
const MyComponent = () => {
  const myButtonRef = useRef();

  const handleClick = () => {
    myButtonRef.current.textContent = "Кнопку натиснуто";
  };

  return (
    <div>
      <button ref={myButtonRef} onClick={handleClick}>
        Натисни мене
      </button>
    </div>
  );
};
```

#### Які є нюанси?

- Використовуйте рефи з обережністю, оскільки це може порушити концепцію управління станом у React.
- У більшості випадків краще уникати використання рефів і віддавати перевагу роботі з даними через стан і пропси.

## Як реалізувати анімацію в React-додатку?
[⬆ Повернутися до списку](#список-запитань)

У React анімації можуть бути реалізовані з використанням різних методів і бібліотек. Ось кілька способів, як це можна зробити:

1. CSS Анімації та Транзиції:
   Ви можете використовувати CSS для створення анімацій і транзицій. Додайте класи з анімацією або транзицією до елементів і змінюйте їхні стилі за допомогою JavaScript або стану компонентів.

2. React Transition Group:
   Це бібліотека, яка полегшує створення анімацій під час додавання, оновлення або видалення компонентів. Вона надає компоненти для управління анімаціями на рівні компонентів.

3. React Spring:
   Це потужна бібліотека для фізичних анімацій (пружинних анімацій). Вона надає хуки та компоненти для створення плавних анімацій.

4. CSS-in-JS бібліотеки:
   Бібліотеки, як-от styled-components і emotion, дають змогу створювати стилі та анімації безпосередньо в JavaScript. Вони надають механізми для створення анімацій на основі стану компонентів.

5. Бібліотеки для анімації SVG:
   Якщо ви працюєте з SVG, ви можете використовувати бібліотеки, як-от react-spring-svg, для анімування SVG елементів.

6. Бібліотеки для анімованих переходів:
   Якщо вам потрібні складні анімовані переходи між різними сторінками, ви можете використовувати бібліотеки, такі як react-router-transition, які надають механізми для анімації переходів між маршрутами.

Приклад використання React Transition Group:

```
import React from "react";
import { CSSTransition } from "react-transition-group";
import "./MyComponent.css";

const MyComponent = ({ show }) => {
  return (
    <CSSTransition in={show} timeout={400} classNames="fade" unmountOnExit>
      <div className="my-component">Вміст компонента</div>
    </CSSTransition>
  );
};

export default MyComponent;
```

У цьому прикладі, коли show дорівнює true, компонент буде анімований під час появи та зникнення за допомогою CSS класів і транзицій.

Зверніть увагу: При створенні анімацій, особливо складних, слід враховувати продуктивність і подбати про те, щоб анімації не сповільнювали роботу вашої програми.

## Як працює механізм "контексту" (context) для передачі даних?
[⬆ Повернутися до списку](#список-запитань)

Механізм "контексту" (context) в React дає змогу передавати дані глибоко вниз по дереву компонентів без явної передачі через пропси на кожному рівні. Це особливо корисно, коли кілька компонентів потребують доступу до одних і тих самих даних.

Контекст складається з двох частин:

1. "постачальник" або "провайдер" (provider);
2. "споживач" (consumer).

**Постачальник (Provider):**
Постачальник визначає дані, які слід передати. Він обертає дерево компонентів, які мають отримати доступ до цих даних, і надає методи для їхнього доступу.

**Споживач (Consumer):**
Споживач використовує методи, надані постачальником, для доступу до даних, переданих через контекст.

Приклад використання контексту:

```
import React, { createContext, useContext } from "react";

// Створюємо контекст
const MyContext = createContext();

// Поставщик данных
const MyProvider = ({ children }) => {
  const sharedData = { message: "Повідомлення з контексту" };

  return <MyContext.Provider value={sharedData}>{children}</MyContext.Provider>;
};

// Компонент-споживач
const MyComponent = () => {
  const data = useContext(MyContext);

  return <div>{data.message}</div>;
};

// Всередині компонента App
function App() {
  return (
    <MyProvider>
      <MyComponent />
    </MyProvider>
  );
}
```

У цьому прикладі компонент `MyComponent` використовує `useContext` для доступу до даних, переданих через контекст. Коли `MyComponent` рендериться всередині `MyProvider`, він автоматично отримує доступ до даних, які були передані через контекст.

Контекст слід використовувати обережно, оскільки він може ускладнити відстеження передачі даних у додатку. Він найбільш корисний для передачі даних, які вважаються глобальними або загальними для багатьох компонентів.

## Що таке портали (portals) у React?
[⬆ Повернутися до списку](#список-запитань)

Портали (portals) - це механізм у React, який дає змогу рендерувати дочірні елементи в DOM-вузли, які знаходяться поза ієрархією DOM-компонента. Це означає, що ви можете рендерити вміст компонента в інший елемент поза поточним деревом компонентів.

Портали корисні, коли вам потрібно рендерити компоненти на верхньому рівні DOM (наприклад, для створення модальних вікон або спливаючих підказок), але зберегти логіку і стан компонента всередині вашого React-додатку.

Приклад використання порталів:

```
import React from "react";
import ReactDOM from "react-dom";

const Modal = ({ children }) => {
  const modalRoot = document.getElementById("modal-root");
  return ReactDOM.createPortal(children, modalRoot);
};

const App = () => {
  return (
    <div>
      <p>Вміст основного компонента</p>
      <Modal>
        <p>Вміст модального вікна</p>
      </Modal>
    </div>
  );
};

ReactDOM.render(<App />, document.getElementById("root"));
```

У цьому прикладі компонент `Modal` використовує портали для рендерингу свого вмісту в DOM-вузлі з id `modal-root`. По суті, `Modal` створює "спливаюче" вікно, яке рендерується на рівні верхнього рівня, але все ще має доступ до стану і методів компонента `App`.

Важливо зазначити, що портали не змінюють ієрархію компонентів у React-додатку, вони просто рендерять вміст в іншому місці в DOM.

## Як реалізувати lazy loading у React з використанням Suspense?
[⬆ Повернутися до списку](#список-запитань)

Ледаче завантаження (lazy loading) у React дає змогу відкладати завантаження компонентів доти, доки вони дійсно не знадобляться. Це може поліпшити продуктивність програми, зменшивши початковий час завантаження.

Для реалізації ледачого завантаження з використанням `Suspense`, ви можете використовувати функцію `React.lazy()`, яка дає змогу ледаче завантажувати динамічні імпорти компонентів. Однак, `React.lazy()` працює тільки з дефолтними експортами компонентів.

Ось як це можна зробити:

1. Створіть компонент, що ліниво завантажується:

```
// LazyComponent.jsx
import React from "react";

const LazyComponent = () => {
  return <div>Ліниво завантажений компонент</div>;
};

export default LazyComponent;
```

2. Використовуйте `React.lazy()` для ледачого завантаження:

```
import React, { Suspense } from "react";

const LazyComponent = React.lazy(() => import("./LazyComponent"));

const App = () => {
  return (
    <div>
      <p>Вміст основного компоненту</p>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
};

export default App;
```

У цьому прикладі `React.lazy()` використовується для ледачого завантаження компонента `LazyComponent`. Обертання `<LazyComponent />` в `<Suspense>` дає змогу вказати компонент-заглушку, який буде показано під час завантаження.

При використанні ледачого завантаження через `React.lazy()`, не забудьте, що це працює тільки з дефолтними експортами компонентів. Якщо ви хочете ліниво завантажити компоненти з іменованими експортами, ви можете використовувати альтернативний підхід з `import()`:

```
const LazyComponent = React.lazy(() => import("./LazyComponent"));
```

## Які нововведення було додано в React 16?
[⬆ Повернутися до списку](#список-запитань)

React 16, також відомий як React Fiber, вніс безліч значних змін і нововведень:

1. Fiber Architecture:
   Було запроваджено нову архітектуру під назвою Fiber, яка дала змогу React більш ефективно обробляти оновлення компонентів, роблячи додатки більш чуйними.

2. Portals:
   Було додано можливість використовувати Portals, що дають змогу рендерити дочірні компоненти за межами ієрархії DOM-вузлів батьківського компонента. Це корисно, наприклад, для створення модальних вікон або спливаючих меню.

3. Error Boundaries:
   Введено Error Boundaries, які дають змогу ізолювати помилки в компонентах, запобігаючи падінню всієї програми. Це допомагає поліпшити стабільність інтерфейсу.

4. Fragment:
   З'явився новий компонент Fragment, який дає змогу групувати дочірні елементи без додавання зайвих DOM-вузлів.

5. Сustom DOM Attributes:
   Тепер можна передавати користувацькі атрибути в DOM-елементи без попереджень.

6. Server-Side Rendering Improvements:
   Покращення в механізмах SSR (Server-Side Rendering) за допомогою нових API та оптимізацій.

7. Return Types:
   Введено нові типи значень, що повертаються, для компонентів, як-от string і number, що дає змогу використовувати елементи, що повертаються функціональними компонентами, як дочірні елементи.

8. Підтримка Map та Set:
   React Elements тепер можуть бути створені з екземплярів Map і Set.

9. Компактніший React:
   Розмір бібліотеки було зменшено за рахунок оптимізацій і видалення застарілого коду.

10. Нові Warnings і Deprecations:
    Було внесено зміни в систему попереджень, а також видалено застарілі методи.

11. Новий рендерер:
    Додано новий експериментальний рендерер під назвою Scheduler, який дає змогу контролювати пріоритети рендерінгу для кращої чуйності інтерфейсу.

12. Подієвий обробник onFocus:
    Введено підтримку обробника onFocus для обробки фокусування на елементах.

13. Новий атрибут forwardRef:
    Додано атрибут forwardRef, що спрощує передавання ref'ів між компонентами.

## Як використовувати React DevTools для налагодження програми?
[⬆ Повернутися до списку](#список-запитань)

React DevTools - це інструмент для розробників, який надає зручні засоби для налагодження та аналізу React-додатків. Ось як використовувати React DevTools для налагодження:

1. Встановлення та налаштування:

- Переконайтеся, що ви встановили React DevTools у вашому браузері. Ви можете знайти його в магазині розширень браузера.
- Після встановлення перезапустіть браузер, щоб зміни набули чинності.

2. Відкриття DevTools:

- Відкрийте веб-додаток, який ви хочете налагодити.
- Натисніть правою кнопкою миші в будь-якому місці сторінки та виберіть "Дослідити елемент" або "Переглянути код" (залежно від браузера). Це відкриє інструменти розробника.

3. Вкладка React:

- В інструментах розробника знайдіть вкладку з назвою "React" або "React" (залежно від браузера та версії DevTools). Зазвичай вона розташована поруч із вкладками "Елементи" та "Консоль".
- Перейдіть на цю вкладку.

4. Інспектування компонентів:

- У React DevTools ви побачите ієрархію компонентів вашої програми.
- Ви можете розкривати компоненти, щоб бачити їхній стан і властивості.
- Виділіть компонент, щоб бачити його поточний стан і пропси праворуч.

5. Зміна стану:

Якщо ви працюєте з компонентами, заснованими на класах, ви можете взаємодіяти з компонентами, змінюючи їхні стани та пропси, натискаючи на них у DevTools.

6. Відстеження оновлень:

React DevTools дає змогу відстежувати, які компоненти були оновлені під час зміни стану або пропсів. Ви побачите, які компоненти перемальовуються, а які ні.

7. Профілювання:

React DevTools також надає інструменти для профілювання продуктивності вашого застосунку, що дає змогу виявити вузькі місця в продуктивності та оптимізувати код.

8. Відстеження помилок:

Якщо у вашому додатку виникають помилки, React DevTools може допомогти вам їх легко відстежити і простежити до конкретних компонентів.

Використання React DevTools істотно полегшує налагодження та аналіз React-додатків, допомагаючи розробникам легко розуміти, як компоненти взаємодіють і як зміни стану впливають на інтерфейс.

## Що таке "хуки" (hooks) у React і для чого вони використовуються?
[⬆ Повернутися до списку](#список-запитань)

Хуки (hooks) у React - це функції, які дають змогу вам "зачепитися" за внутрішній стан і функціональність React компонентів. Вони були представлені в React 16.8 і дали змогу функціональним компонентам використовувати стан та інші можливості, які раніше були доступні тільки класовим компонентам. Хуки дають змогу писати чистіший, читабельніший і перевикористовуваний код.

#### Приклади хуків:

1. **useState:**
   Дозволяє функціональним компонентам мати локальний стан. Ви можете визначити змінні стану та функції для їхнього оновлення. Приклад:

```
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Підрахунок: {count}</p>
      <button onClick={() => setCount(count + 1)}>Збільшення</button>
    </div>
  );
}
```

2. **useEffect:**
   Дозволяє виконувати побічні ефекти у функціональних компонентах. Наприклад, виконання коду після рендерингу компонента, робота з асинхронними запитами і підписками. Приклад:

```
import React, { useState, useEffect } from "react";

function DataFetching() {
  const [data, setData] = useState([]);

  useEffect(() => {
    fetchData(); // Тут може бути код для отримання даних
  }, []);

  return (
    <ul>
      {data.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

3. **useContext**:
   Дозволяє отримувати доступ до контексту з компонента. Контекст - це спосіб передачі даних глибоко в дерево компонентів без явної передачі через пропси. Приклад:

```
import React, { useContext } from "react";
import { ThemeContext } from "./ThemeContext";

function ThemedButton() {
  const theme = useContext(ThemeContext);

  return (
    <button style={{ background: theme.background, color: theme.color }}>
      Тематична кнопка
    </button>
  );
}
```

Хуки дають змогу розбивати логіку на дрібніші й керованіші частини, роблячи компоненти чистішими та легшими для тестування. Вони також усувають необхідність у класових компонентах у більшості випадків, що робить код зрозумілішим і скорочує обсяг бойлерплейта.

## Як створити власний хук у React?
[⬆ Повернутися до списку](#список-запитань)

Створення власних хуків дає змогу абстрагувати та перевикористовувати логіку між різними компонентами. Щоб створити власний хук, виконайте такі кроки:

1. Створення функції хука:

Створіть функцію, яка представлятиме ваш хук. Назва хука зазвичай починається з "use", щоб відповідати угоді і щоб React правильно його розпізнавав як хук.

Ця функція може містити будь-яку логіку, яку ви хочете розділити між компонентами.

2. Визначення стану та функцій оновлення (за необхідності):

Якщо ваш хук повинен керувати станом, використовуйте `useState` для створення стану та функцій для його оновлення.

3. Повернення даних і функцій:

Поверніть дані та функції, які компоненти будуть використовувати. Зазвичай це робиться у вигляді об'єкта.

4. Використання хука в компоненті:

Імпортуйте ваш хук у компонент, де ви хочете використовувати цю логіку.
Викличте функцію хука в компоненті та отримайте необхідні дані та функції.

Ось приклад, як це може виглядати:

```
import { useState } from "react";

// Створюємо власний хук
function useCounter(initialCount) {
  const [count, setCount] = useState(initialCount);

  const increment = () => {
    setCount(count + 1);
  };

  const decrement = () => {
    setCount(count - 1);
  };

  return {
    count,
    increment,
    decrement,
  };
}

// Використовуємо хук у компоненті
function CounterComponent() {
  const { count, increment, decrement } = useCounter(0);

  return (
    <div>
      <p>Порахуйте: {count}</p>
      <button onClick={increment}>Збільшення</button>
      <button onClick={decrement}>Відкладення</button>
    </div>
  );
}
```

Створений хук `useCounter` інкапсулює стан лічильника і функції для його оновлення. Це дає змогу використовувати ту саму логіку лічильника в різних компонентах без дублювання коду.

Зверніть увагу, що хуки не можуть бути асинхронними, і їх не можна викликати всередині умов або циклів, адже порядок викликів хуків у компоненті має бути постійним.

## Як обробляти помилки в React-додатку за допомогою Error Boundary?
[⬆ Повернутися до списку](#список-запитань)

Error Boundary (граничні помилки) в React - це компоненти, які обертають інші компоненти і дають змогу перехоплювати й обробляти помилки, що сталися в дочірніх компонентах під час рендерингу. Вони запобігають "провалюванню" помилок на рівень вище і дають змогу гладко обробити проблеми в інтерфейсі.

#### Ось як створити Error Boundary:

1. Створення Error Boundary компонента:

Створіть новий компонент, який слугуватиме вам як Error Boundary.

Він має реалізувати методи `componentDidCatch(error, info)`.

2. Обробка помилок у методі `componentDidCatch`:

У методі `componentDidCatch` ви можете обробити помилку, наприклад, показавши користувачеві повідомлення або записавши деталі помилки в логи.

3. Використання Error Boundary:

Оберніть компоненти, які ви хочете захистити, всередині створеного Error Boundary компонента.

Коли помилка станеться всередині дочірніх компонентів, Error Boundary перехопить її і спрацює метод componentDidCatch.

Приклад:

```
import React, { Component } from "react";

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
    };
  }

  componentDidCatch(error, info) {
    this.setState({ hasError: true });
    // Тут можна виконати логування або інші дії з обробки помилки
  }

  render() {
    if (this.state.hasError) {
      return <div>Щось пішло не так. Ми працюємо над цією проблемою.</div>;
    }
    return this.props.children;
  }
}

// Застосування Error Boundary
class App extends Component {
  render() {
    return (
      <div>
        <h1>Мій застосунок</h1>
        <ErrorBoundary>
          {/* Компоненти, які будуть захищені від помилок */}
        </ErrorBoundary>
      </div>
    );
  }
}
```

Важливо зазначити, що Error Boundary не перехоплює помилки в асинхронних операціях, усередині подієвих обробників або всередині інших Error Boundary. Тому гарною практикою є обертання лише тих компонентів, які є окремими модулями та ймовірно можуть спричинити помилки.

## Як працює алгоритм узгодження (reconciliation) у React?
[⬆ Повернутися до списку](#список-запитань)

Алгоритм узгодження в React - це процес порівняння віртуального DOM (VDOM) попереднього і поточного станів компонента, щоб визначити, які зміни необхідно внести в реальний DOM для відображення нового стану. Він дає змогу мінімізувати зміни в DOM і забезпечує ефективне оновлення інтерфейсу.

#### Ось як працює алгоритм узгодження:

1. Створення віртуального DOM:

Під час першого рендерінгу компонента React створює віртуальне дерево елементів (віртуальний DOM), що представляє структуру компонентів і їхні властивості.

2. Порівняння віртуальних DOM:

Коли компонент перемальовується, React створює нове віртуальне дерево для нового стану.

Потім порівнює нове віртуальне дерево з попереднім, враховуючи ієрархію і ключі елементів.

3. Визначення змін:

У результаті порівняння React визначає, які елементи змінилися, які додалися або видалені.

Ключі елементів допомагають React визначити, які елементи перемістилися, а які змінені.

4. Генерація пакета змін (diff):

На основі визначених змін React генерує пакет змін (diff), який описує, які зміни потрібно внести в реальний DOM.

5. Застосування змін у DOM:

React застосовує пакет змін до реального DOM.

Це може включати вставку, оновлення або видалення елементів залежно від типу змін.

6. Виклик методів життєвого циклу:

Після оновлення реального DOM React викликає відповідні методи життєвого циклу компонентів (наприклад, `componentDidUpdate`).

7. Асинхронність і пакетна обробка:

React може групувати кілька оновлень в одну операцію, щоб зменшити кількість змін у DOM та оптимізувати продуктивність.

React також може оптимізувати порядок оновлень для ефективнішого застосування змін.

Алгоритм узгодження дає змогу React рендерити компоненти ефективно, мінімізуючи кількість дорогих операцій оновлення DOM. Це робить React потужною бібліотекою для створення швидких і чуйних користувацьких інтерфейсів.

## Які популярні бібліотеки для управління станом ви знаєте, крім вбудованого `useState`?
[⬆ Повернутися до списку](#список-запитань)

Крім вбудованого useState у React, існує низка популярних сторонніх бібліотек для керування станом у застосунках. Деякі з них:

**1) Redux: **Одна з найпопулярніших бібліотек для управління станом. Вона надає передбачуваний спосіб організації стану, централізоване сховище та дії для зміни стану. Redux широко використовується у великих і складних додатках.

**2) Mobx:** Ще одна бібліотека управління станом, яка забезпечує реактивне програмування. Mobx дає змогу визначати спостережувані дані й автоматично оновлювати компоненти в разі їхньої зміни.

**3) Mobx-State-Tree (MST):** Це розширення Mobx, що надає більш сувору структуру для організації стану програми. MST дає змогу створювати моделі даних із певними типами, діями та обчислюваними значеннями.

**4) Zustand:** Це легка бібліотека управління станом, яка підходить для невеликих і середніх додатків. Вона використовує функціональне програмування та хук useReducer, щоб надати простий API для роботи зі станом.

**5) Recoil: **Бібліотека, розроблена Facebook, яка призначена для управління станом у React-додатках. Вона ґрунтується на концепції атомів і селекторів, що дає змогу більш декларативно описувати стан і його залежності.

**6) Easy Peasy: **Це бібліотека, створена на основі Redux, але зі спрощеним синтаксисом. Вона надає більш легке та інтуїтивне API для управління станом.

**7) Valtio:** Ще одна легка бібліотека для управління станом. Вона використовує проксі-об'єкти для відстеження змін та автоматичного оновлення компонентів.

Кожна з цих бібліотек має свої особливості та підходи до управління станом у React-додатках. Вибір бібліотеки залежить від складності програми, ваших уподобань і досвіду.

## Каким образом можно оптимизировать рендеринг компонентов в React?
[⬆ Повернутися до списку](#список-запитань)

Оптимізація візуалізації компонентів у React допомагає поліпшити продуктивність вашого застосунку та забезпечити більш плавний користувацький досвід. Ось кілька способів, як можна оптимізувати рендеринг компонентів:

**1) Використання ключів (Keys):**

Під час відображення списків елементів у React, приділяйте увагу унікальним ключам (key).

Ключі допомагають React визначити, які елементи були додані, змінені або видалені, що допомагає скоротити кількість змін у DOM.

**2) Уникнення непотрібних рендерів:**

Використовуйте методи `shouldComponentUpdate` (у класових компонентах) або `React.memo` (у функціональних компонентах), щоб запобігти непотрібним перемальовуванням.

Вони дають змогу перевірити, чи дійсно компонент потрібно оновлювати під час зміни стану або пропсів.

**3) Використання PureComponent та memo:**

Скористайтеся `PureComponent` (у класових компонентах) або `React.memo` (у функціональних компонентах) для автоматичної перевірки змін пропсів і стану перед оновленням компонента.

**4) Поділ компонентів:**

Розбийте великі компоненти на дрібніші, щоб зменшити сферу оновлення і зробити код більш модульним.

**5) Використання хуків:**

Хуки, як-от `useMemo` чи `useCallback`, дають змогу кешувати значення і колбеки, що зменшує надлишкові обчислення та оновлення.
** 6) Ліниве завантаження (Lazy Loading):**

Використовуйте ледаче завантаження для окремих компонентів за допомогою `React.lazy` та `Suspense`, щоб завантажувати компоненти тільки тоді, коли вони дійсно знадобляться.

**7) Оптимізовані список:**

Для відображення великих списків використовуйте бібліотеки, такі як `react-virtualized` або `react-window`, щоб візуалізувати лише видимі елементи.

**8) Пакетне оновлення (Batching):**

React автоматично групує кілька оновлень стану або пропсів в одну операцію, щоб зменшити кількість змін у DOM.

**9) Використання Production Build:**

Під час розгортання застосунку використовуйте оптимізований "production" білд React, який включає мінімізований код та інші оптимізації.

**10) Профілювання:**

Використовуйте інструменти профілювання React, такі як React DevTools Profiler, щоб виявити вузькі місця в продуктивності та оптимізувати їх.

Оптимізація візуалізації компонентів - це постійний процес, оскільки продуктивність може залежати від конкретного застосунку та його контексту. Регулярне вивчення нових інструментів і методів допоможе поліпшити продуктивність вашого React-додатку.

## Що таке "глибоке порівняння" (deep comparison) у контексті оптимізації продуктивності React?
[⬆ Повернутися до списку](#список-запитань)

"Глибоке порівняння" (deep comparison) - це процес порівняння двох об'єктів або структур даних на основі їхніх внутрішніх значень, а не на основі посилань або ідентифікаторів. У контексті оптимізації продуктивності React, глибоке порівняння використовується для визначення, чи змінилися дані в компонентах, і чи варто перемальовувати компонент через ці зміни.

Під час роботи з React, компоненти можуть перемальовуватися під час зміни стану або пропсів. Однак, якщо компонент перемальовується занадто часто, це може негативно позначитися на продуктивності, оскільки кожне оновлення компонента вимагає виконання низки операцій, включно з генерацією віртуального DOM і оновленням реального DOM.

Щоб уникнути надлишкових перемальовувань, React використовує механізми оптимізації, такі як "поверхневе порівняння" (shallow comparison) і "глибоке порівняння" (deep comparison).

1. Поверхневе порівняння (Shallow Comparison):

Під час поверхневого порівняння React порівнює значення пропсів і стани компонентів. Якщо значення не змінилися, React припускає, що компонент можна не перемальовувати.

2. Глибоке порівняння (Deep Comparison):

Глибоке порівняння використовується, коли дані являють собою складні структури, наприклад, вкладені об'єкти або масиви. У цьому випадку React перевіряє не тільки посилання на об'єкти, а й їхній вміст.

Якщо будь-які вкладені дані змінилися, компонент буде перемальований.

Однак глибоке порівняння може бути ресурсоємним, особливо для великих структур даних. Тому, у певних випадках, корисно використовувати методи оптимізації, як-от `React.memo` (у функціональних компонентах) або `shouldComponentUpdate` (у класових компонентах), щоб керувати поведінкою перемальовок на основі глибокого порівняння.

## Як використовувати memoization для оптимізації компонентів?
[⬆ Повернутися до списку](#список-запитань)

Memoization - це техніка оптимізації, яка дає змогу кешувати результати виконання функції та використовувати їх під час повторних викликів із тими самими аргументами. Це може бути корисно, коли компоненти вашого застосунку мають високу обчислювальну складність і часто викликаються з одними й тими самими вхідними даними.

Для використання **memoization** ви можете використовувати різні підходи. Одним із поширених є використання бібліотеки memoizee для JavaScript. Вона надає декоратори, які можна застосовувати до функцій, щоб автоматично кешувати їхні результати.

Ось приклад використання memoizee:

```
const memoize = require("memoizee");

const expensiveFunction = (param) => {
  // Деякі дорогі обчислення...
  повернути result;
};

const memoizedFunction = memoize(expensiveFunction);

// Тепер при повторних викликах з тими самими аргументами
// буде використовуватися кешований результат

const result1 = memoizedFunction("param1");
const result2 = memoizedFunction("param2");
const result3 = memoizedFunction("param1"); // Буде використано кешований результат

console.log(result1);
console.log(result2);
console.log(result3);
```

Таким чином, завдяки **memoization** можна істотно знизити кількість повторних обчислень і поліпшити продуктивність компонентів.

## Які патерни використання Redux ви знаєте?
[⬆ Повернутися до списку](#список-запитань)

**Redux** - це популярна бібліотека для управління станом програми в JavaScript. Вона пропонує низку патернів використання, які допомагають організувати код і полегшити розробку. Ось деякі з них:

**1) Action-Creator Pattern: **
Цей патерн полягає у створенні функцій-творців дій (action creators), які повертають об'єкти з інформацією про подію або запит до зміни стану. Наприклад, const increment = (amount) => { return { type: 'INCREMENT', payload: amount }; }. Це допомагає стандартизувати створення дій і зробити їх зручнішими для використання.

**2) Reducer Pattern: **
У Redux редьюсери (reducers) використовуються для визначення, як змінюється стан застосунку під час отримання дій. Редьюсер - це чиста функція, яка приймає поточний стан і дію, і повертає новий стан. Паттерн пропонує розділити зміну стану на невеликі функції, кожна з яких відповідальна за зміну своєї частини стану.

**3) Store Pattern: **
Центральним пунктом у Redux є сховище (store), яке містить увесь стан застосунку. Сховище дає змогу отримувати поточний стан, оновлювати його за допомогою дій і підписуватися на зміни стану для оновлення користувацького інтерфейсу.

**4) Middleware Pattern: **
Redux надає можливість використовувати middleware - проміжні шари для обробки дій перед їхнім досягненням до редьюсерів. Це дає змогу виконати додаткові дії, як-от логування, опрацювання асинхронних запитів або зміна дій перед їхнім опрацюванням. Прикладами middleware у Redux є redux-thunk і redux-saga.

**5) Container and Presentational Components Pattern: **
Цей патерн пропонує розділити компоненти на дві категорії: контейнерні компоненти (container components), які відповідають за під'єднання до сховища та передавання даних; та презентаційні компоненти (presentational components), які займаються лише візуалізацією та зворотним зв'язком із користувачем. Це покращує читабельність, перевикористовуваність і тестованість компонентів.

Це лише деякі патерни, які можна використовувати з Redux. Кожен із них має свої переваги і може бути застосований залежно від вимог і складності вашого застосунку.

## Як працює бібліотека React Router?
[⬆ Повернутися до списку](#список-запитань)

React Router - це популярна бібліотека для керування маршрутизацією (навігацією) у додатках на основі React. Вона дає змогу створювати односторінкові додатки (SPA), де контент змінюється динамічно без повного перезавантаження сторінки. Ось як працює React Router:

**1) Встановлення та налаштування: **

Спочатку потрібно встановити React Router за допомогою пакетного менеджера, наприклад, npm або yarn. Після встановлення необхідно імпортувати компоненти з бібліотеки та налаштувати маршрути для застосунку.

**2) Визначення маршрутів: **

Ви визначаєте маршрути у вашому застосунку за допомогою компонентів, що надаються React Router, таких як:

- BrowserRouter,
- Route,
- Switch
- Link.

Компонент `BrowserRouter` обертає кореневий компонент додатка і забезпечує навігацію.

**3) Компоненти маршрутизації: **

Ви використовуєте компоненти `Route`, щоб пов'язати певні маршрути з відповідними компонентами. Наприклад, ви можете визначити маршрут "/about" і пов'язати його з компонентом `About`.

**4) Навігація: **

Для створення посилань між різними маршрутами ви використовуєте компонент `Link`. Він дозволяє створювати клікабельні посилання, які перемикаються між маршрутами без повного перезавантаження сторінки.

**5) Перемикання між маршрутами: **

Коли користувач переходить за посиланням або вводить URL, React Router визначає відповідний маршрут і рендерить відповідний компонент, пов'язаний із цим маршрутом.

**6) Додаткові можливості: **

React Router також надає додаткові функції, як-от параметри маршрутів, вкладені маршрути, захист маршрутів тощо.

Загалом, React Router спрощує управління навігацією у вашому React-додатку, забезпечуючи плавні переходи між різними "сторінками" в межах однієї сторінки.

## Що таке SSR (Server-Side Rendering) і як він відрізняється від CSR (Client-Side Rendering)?
[⬆ Повернутися до списку](#список-запитань)

SSR (Server-Side Rendering) - це метод веб-розробки, за якого контент веб-сторінки генерується на сервері та потім відправляється браузеру як повністю сформована HTML-сторінка. Це дає змогу браузеру одразу ж відобразити контент, що позитивно впливає на SEO, індексацію та час завантаження сторінки для користувачів, особливо за повільного інтернет-з'єднання.

#### У чому різниця між SSR і CSR?

**CSR (Client-Side Rendering)** - це підхід, за якого вся логіка відображення контенту відбувається в браузері. Спочатку сервер відправляє мінімальний HTML і JavaScript, а потім браузер завантажує скрипти і запитує дані для відображення. Це може створювати більш інтерактивні користувацькі інтерфейси, але також може спричиняти повільне завантаження сторінки і проблеми з SEO.

##### Основні відмінності:

1. Завантаження сторінки:

У SSR більша частина контенту вже є у вихідному HTML, тому сторінка швидше відображається. У CSR контент генерується браузером після завантаження скриптів, що може викликати повільне початкове завантаження.

2. SEO:

SSR має перевагу для SEO, оскільки пошукові системи можуть легко проіндексувати контент на сторінці, оскільки він уже присутній у вихідному HTML. У CSR це вимагає додаткових зусиль для індексації.

3. Інтерактивність:

CSR може надавати більш плавні переходи та інтерактивність, оскільки більша частина роботи відбувається на стороні клієнта. У SSR інтерактивність обмежена тим, що було попередньо згенеровано на сервері.

Обидва підходи мають свої плюси і мінуси, і вибір між ними залежить від конкретних вимог проєкту і пріоритетів веб-розробників.

## Як реалізувати асинхронне завантаження компонентів за допомогою React Router?
[⬆ Повернутися до списку](#список-запитань)

Асинхронне завантаження компонентів, також відоме як "ледаче завантаження" (lazy loading), дає змогу завантажувати компоненти тільки тоді, коли вони справді потрібні, що може значно поліпшити продуктивність вашого застосунку. У React Router для цього використовується функція `React.lazy()` у поєднанні з динамічним імпортом і `Suspense`. Ось як це робиться:

1. Використання `React.lazy()`:

Ви можете використовувати функцію `React.lazy()` для асинхронного завантаження компонентів. Ця функція приймає функцію, що повертає проміс, який дозволяється в модуль із компонентом. Наприклад:

```
const MyComponent = React.lazy(() => import("./MyComponent"));
```

2. Додавання `Suspense`:

Коли ви використовуєте асинхронне завантаження, ви також маєте використати компонент `Suspense`, який очікуватиме завантаження асинхронних компонентів. Загорніть точку входу вашого додатка (зазвичай навколо компонента `<Router>`) у `<Suspense>` та вкажіть `fallback` - компонент, який відображатиметься під час завантаження:

```
import {
  BrowserRouter as Router,
  Route,
  Switch,
  Link,
} from "react-router-dom";

const MyComponent = React.lazy(() => import("./MyComponent"));

function App() {
  return (
    <Router>
      <div>
        <nav>
          <ul>
            <li>
              <Link to="/">Home</Link>
            </li>
            <li>
              <Link to="/lazy">Lazy Component</Link>
            </li>
          </ul>
        </nav>

        <hr />

        <Suspense fallback={<div>Loading...</div>}>
          <Switch>
            <Route exact path="/">
              {/* Рендер компонента для головної сторінки */}
            </Route>
            <Route path="/lazy" component={MyComponent} />
          </Switch>
        </Suspense>
      </div>
    </Router>
  );
}
```

Тепер, коли користувач перейде на маршрут `/lazy`, компонент `MyComponent` буде асинхронно завантажуватися тільки в момент його дійсного відображення на екрані. У цей час відобразиться `fallback` (у цьому випадку "Loading...").

Це дає змогу вашому застосунку ефективно використовувати ресурси, завантажуючи тільки ті компоненти, які дійсно потрібні користувачеві.

## Які переваги дає використання Redux для управління станом застосунку:
[⬆ Повернутися до списку](#список-запитань)

1. Централізоване сховище:
   Redux надає єдине централізоване сховище для всього стану вашого застосунку. Це робить управління та відстеження стану більш прозорим і передбачуваним.

2. Передбачуваність:
   Стан у Redux є незмінним, і його зміни відбуваються через чисті функції - редюсери. Це призводить до передбачуваної поведінки під час оновлення стану і легше виявляти помилки.

3. Спрощене управління станом:
   Redux надає патерн управління станом Flux, який спрощує складні випадки управління станом, особливо у великих додатках.

4. Легкість відстеження змін:
   Стан у Redux змінюється тільки через дії (actions), які явно описують, що відбулося в додатку. Це спрощує відстеження історії змін і налагодження.

5. Відокремлення стану від компонентів:
   Redux дає змогу відокремити стан застосунку від компонентів, що покращує масштабованість і дає змогу повторно використовувати компоненти.

6. Легкість тестування:
   Чисті функції редюсерів і передбачуваність змін стану роблять тестування Redux-логіки простішим і надійнішим.

7. Підтримка інструментів розробника:
   Існують інструменти розробника, як-от Redux DevTools, які полегшують відстеження та запис змін стану в часі.

8. Розширюваність:
   Redux має багату екосистему плагінів і засобів для поліпшення та розширення функціональності.

9. Сумісність із різними фреймворками:
   Redux можна використовувати не тільки з React, а й з іншими фреймворками та бібліотеками.

10. Покращене управління асинхронними операціями:
    За допомогою middleware, такого як Redux Thunk або Redux Saga, Redux спрощує управління асинхронними операціями, такими як запити до сервера.

Хоча Redux може додати деяку складність у маленьких проєктах, у великих і складних додатках його патерн та інструменти можуть істотно поліпшити організацію, масштабованість і обслуговуваність коду.

## Що таке Redux Thunk?
[⬆ Повернутися до списку](#список-запитань)

**Redux Thunk** - це middleware (проміжне програмне забезпечення) для Redux, яке дає змогу обробляти асинхронні дії (actions) у Redux-додатку. У Redux асинхронні операції, такі як запити до сервера, зазвичай не можуть бути виконані безпосередньо всередині дій через синхронну природу редюсерів. Redux Thunk вирішує цю проблему, дозволяючи створювати дії, які є функціями замість об'єктів.

#### Як це працює?

Звичайна дія Redux являє собою об'єкт, наприклад:

```
const action = {
  type: "SOME_ACTION",
  payload: someData,
};
```

З використанням Redux Thunk, дії стають функціями, які можуть виконувати асинхронні операції, і мають доступ до методу `dispatch` і поточного стану:

```
const asyncAction = () => (dispatch, getState) => {
  // Виконуємо асинхронні операції, наприклад, запит до сервера
  fetch("https://api.example.com/data")
    .then((response) => response.json())
    .then((data) => {
      dispatch({ type: "FETCH_SUCCESS", payload: data });
    })
    .catch((error) => {
      dispatch({ type: "FETCH_FAILURE", payload: error });
    });
};
```

Тут `asyncAction` - це функція, яка, коли викликається, повертає функцію з двома аргументами: `dispatch` та `getState`. Усередині цієї функції можна виконувати асинхронні операції та викликати `dispatch` для надсилання відповідних дій у стор Redux.

#### Переваги Redux Thunk:

1. Простота використання:
   Redux Thunk дає змогу створювати асинхронні дії з легкістю, не вимагаючи переходу до складніших бібліотек управління побічними ефектами, таких як Redux Saga або Redux Observable.

2. Інтеграція з наявним кодом:
   Redux Thunk добре інтегрується з наявним кодом Redux, тож ви можете поступово перекладати асинхронні операції на його використання без необхідності переписування всього коду.

3. Гнучкість:
   Redux Thunk дає вам більшу гнучкість у тому, як ви керуєте асинхронними операціями у вашому додатку.

## Як працює Redux Saga?
[⬆ Повернутися до списку](#список-запитань)

Redux Saga - це бібліотека для управління побічними ефектами в Redux-додатках. Вона надає альтернативний спосіб опрацювання асинхронних операцій, таких як запити до сервера, опрацювання подій та інші побічні ефекти. Ось як працює Redux Saga:

1. Генератори:
   Redux Saga використовує генератори, спеціальний тип функцій JavaScript, що дає змогу зупинити виконання функції, а потім відновити його. Генератори часто використовуються для представлення асинхронних операцій як послідовності кроків.

2. Ефекти:
   У Redux Saga операції, які представляють побічні ефекти, називаються "ефектами". Ефекти - це об'єкти, які описують, як Redux Saga має обробити побічні ефекти. Наприклад, `call` для виклику функцій, `put` для надсилання дій, `take` для очікування дій тощо.

3. Саги:
   Саги - це спеціальні генератори, які описують послідовність кроків для обробки певного типу побічних ефектів. Саги стежать за певними діями і, коли такі дії відбуваються, вони запускають відповідні генератори.

4. Middleware:
   Redux Saga підключається до Redux через middleware. Це означає, що саги працюють паралельно зі звичайними діями і редюсерами Redux, обробляючи побічні ефекти.

5. Асинхронні операції:
   Redux Saga обробляє асинхронні операції, як-от запити до сервера, створюючи саги, які слухають певні дії, запускають генератори для оброблення цих дій і взаємодіють з ефектами, як-от `call` і `put`, щоб керувати асинхронними операціями.

6. Скасування операцій:
   Однією з переваг Redux Saga є можливість легко скасовувати та контролювати асинхронні операції, використовуючи такі концепції як `takeLatest`, `takeEvery` тощо.

7. Тестування:
   Redux Saga має хорошу підтримку для тестування завдяки тому, що кожен етап саги може бути явно керований.

Redux Saga надає складніший, але потужніший підхід до управління побічними ефектами, що робить код більш структурованим і легшим для тестування.

## Як реалізувати ледаче завантаження Redux-редьюсерів?
[⬆ Повернутися до списку](#список-запитань)

Ледаче завантаження Redux-редьюсерів може бути корисним, коли у вас є великий Redux-додаток із безліччю редьюсерів, і ви хочете оптимізувати початкове завантаження програми. Redux дозволяє динамічно додавати редьюсери до сховища за допомогою методу `store.replaceReducer()`.

Ось як можна реалізувати ледаче завантаження Redux-редьюсерів:

1. Розділіть редьюсери за модулями:
   Замість того щоб мати один великий файл із редьюсерами, розділіть їх на модулі відповідно до функціональності або розділів програми.

2. Використовуйте `combineReducers` для кожного модуля:
   У кожному модулі створіть свій власний набір редьюсерів за допомогою функції `combineReducers` з Redux.

3. Створіть функцію для ледачого завантаження:
   Для кожного модуля створіть функцію, яка повертатиме проміс, що дозволяє `combineReducers` для цього модуля. Це можна зробити за допомогою динамічного імпорту.

Приклад:

```
// Модуль "counter"
export const loadCounterReducers = () =>
  import("./counter/reducers").then((module) => module.default);

// Модуль "user"
export const loadUserReducers = () =>
  import("./user/reducers").then((module) => module.default);
```

4. Динамічно підключіть редьюсери:
   У точці входу вашого застосунку (зазвичай у файлі, де ви створюєте сховище Redux), ви можете динамічно підключати редьюсери, використовуючи функції для ледачого завантаження і метод `store.replaceReducer()`:

```
import { createStore } з "redux";
import { loadCounterReducers, loadUserReducers } from "./lazyReducers";

const rootReducer = combineReducers({
  // Ваші початкові редюсери
});

const store = createStore(rootReducer);

// Завантажуємо редьюсери по мірі необхідності
loadCounterReducers().then((counterReducers) => {
  store.replaceReducer(
    combineReducers({
      ...rootReducer,
      ...counterReducers,
    })
  );
});

loadUserReducers().then((userReducers) => {
  store.replaceReducer(
    combineReducers({
      ...rootReducer,
      ...userReducers,
    })
  );
});
```

Зверніть увагу, що цей підхід може додати складності в управлінні станом і вимагає ретельного тестування. У великих додатках він може допомогти оптимізувати початкове завантаження і поліпшити продуктивність.

## Що таке "нормалізація стану" (state normalization) у контексті керування станом програми?
[⬆ Повернутися до списку](#список-запитань)

Нормалізація стану (state normalization) - це патерн управління станом, який використовується для організації даних у сховищі таким чином, щоб забезпечити ефективне зберігання, оновлення та доступ до даних у Redux або інших системах управління станом.

Основна ідея нормалізації полягає в тому, щоб зберігати дані в нормалізованій формі, де кожен тип даних зберігається в окремій колекції (таблиці), і використовуються посилання між різними колекціями для усунення дублювання даних і полегшення оновлення.

Приклад: Припустимо, у нас є список постів і список коментарів до цих постів. Замість зберігання коментарів усередині кожного поста (що може призвести до дублювання даних), ми можемо створити дві колекції: "пости" і "коментарі", і використовувати ідентифікатори постів у коментарях для встановлення зв'язку між ними.

#### Переваги нормалізації стану:

**1) Економія місця: **
Дублювання даних зменшується, оскільки одні й ті самі дані не зберігаються в декількох місцях.

**2) Легкість оновлення: **
Зміна даних в одній колекції автоматично відображається в інших, де ці дані використовуються.

**3) Швидкий доступ: **
Пошук, фільтрація і доступ до даних прискорюються, оскільки дані розділені на більш дрібні колекції.

**4) Прозорість: **
Структуру сховища стає легше зрозуміти і відстежити.

У той час як нормалізація може допомогти в оптимізації та управлінні станом, вона також додає складності в логіку оновлення даних і може вимагати додаткової роботи при виборі даних для відображення в компонентах. Вам варто вибрати підхід залежно від розміру та складності вашого застосунку.

## Як створити анімований перехід між сторінками за допомогою React Router?
[⬆ Повернутися до списку](#список-запитань)

Для створення анімованих переходів між сторінками з використанням React Router ви можете використовувати такий підхід:

1. Використовуйте CSS-анімації:
   Найпростіший спосіб додати анімацію - це використовувати CSS-анімації. Ви можете визначити анімацію для елементів, які з'являються або зникають під час переходу між сторінками.

2. Використовуйте бібліотеки анімацій:
   Існує безліч бібліотек анімацій, таких як `react-transition-group`, які спрощують створення анімацій переходів. Вони дають змогу вам вказати, які елементи мають анімуватися під час монтування та розмонтування.

Приклад використання `react-transition-group`:

```
import { CSSTransition } from "react-transition-group";
import { BrowserRouter as Router, Route, Switch, Link } from "react-router-dom";
import "./styles.css";

function App() {
  return (
    <Router>
      <div>
        <nav>
          <ul>
            <li>
              <Link to="/">Home</Link>
            </li>
            <li>
              <Link to="/about">About</Link>
            </li>
          </ul>
        </nav>

        <hr />

        <Switch>
          <Route exact path="/">
            <Home />
          </Route>
          <Route path="/about">
            <About />
          </Route>
        </Switch>
      </div>
    </Router>
  );
}

function Home() {
  return (
    <CSSTransition in={true} appear={true} timeout={300} classNames="fade">
      <div className="home">Home Page</div>
    </CSSTransition>
  );
}

function About() {
  return (
    <CSSTransition in={true} appear={true} timeout={300} classNames="fade">
      <div className="about">About Page</div>
    </CSSTransition>
  );
}
```

3. Користувацькі анімації:
   Якщо вам потрібна складніша анімація, ви можете створити свої власні анімації за допомогою бібліотек для анімацій, таких як `framer-motion` або `react-spring`.

Не забудьте налаштувати відповідні стилі та класи для анімацій у вашому CSS.

## Як працюють CSS-модулі (CSS Modules) у React?
[⬆ Повернутися до списку](#список-запитань)

CSS-модулі є підходом до організації стилів у додатку React, який допомагає ізолювати стилі компонентів і уникнути конфліктів імен класів. Ось як це працює:

**1) Створення модулів стилів: **
Для кожного компонента створюється файл із розширенням `.module.css` або аналогічне за допомогою препроцесорів. Наприклад, `Button.module.css`. У цьому файлі визначаються стилі як зазвичай, але імена класів перетворюються в унікальні імена.

**2) Використання стилів: **
У компоненті React ви можете імпортувати стилі з модуля, як звичайний об'єкт. Наприклад:

```
import React from 'react';
import styles from './Button.module.css';

const Button = () => {
  return <button className={styles.button}>Натисни мене</button>;
};

export default Button;
```

Тут `styles.button` - це унікальне ім'я класу з модуля стилів.

**3) Автоматична локалізація імен класів: **
Під час складання проєкту інструмент CSS-модулів автоматично генерує унікальні імена класів для кожного компонента. Це запобігає перетину стилів між різними компонентами.

**4) Локальні стилі: **
Стилі, визначені всередині модуля, обмежені областю видимості цього модуля. Вони не перетинаються з іншими стилями навіть у тому самому файлі.

**5) Підтримка CSS імен: **
Ви можете використовувати зрозумілі імена класів у ваших стилях, оскільки імена класів із модулів не конфліктуватимуть із глобальними іменами.

**6) Додаткові можливості: **
Деякі інструменти надають додаткові можливості, такі як успадкування стилів, глобальні стилі тощо, щоб полегшити управління стилями.

Використання CSS-модулів робить структуру стилів чіткішою та впорядкованішою, знижуючи ймовірність помилок і полегшуючи спільну розробку.

## Що таке Styled Components, і як воно використовується?
[⬆ Повернутися до списку](#список-запитань)

Styled Components - це бібліотека для стилізації компонентів у React. Вона надає можливість визначати стилі безпосередньо всередині компонентів з використанням синтаксису шаблонних рядків (template literals). Це дає змогу створювати компоненти, які містять як логіку, так і стилі, роблячи код більш читабельним і підтримуваним.

#### Ось як працює Styled Components:

1. Встановлення та імпорт:
   Почніть зі встановлення Styled Components через npm або yarn. Після встановлення ви можете імпортувати функції та компоненти з бібліотеки у свій проєкт.

2. Створення стилізованих компонентів:
   Для створення стилізованих компонентів використовуйте функції зі Styled Components.

Наприклад:

```
import styled from 'styled-components';

const Button = styled.button`
  background-color: #070707;
  color: white;
  border: none;
  padding: 15px 25px;
  cursor: pointer;
`;
```

Тут `styled.button` створює компонент `<button>`, до якого застосовано зазначені стилі.

3. Використання стилізованих компонентів:
   Тепер ви можете використовувати стилізований компонент `Button` так само, як і звичайний компонент:

```
import React from 'react';
import Button from './Button';

const App = () => {
  return (
    <div>
      <Button>Натисни мене</Button>
    </div>
  );
};

export default App;
```

4. Передача пропсів:
   Ви також можете передавати пропси в стилізовані компоненти та використовувати їх усередині рядків шаблону:

```
const Button = styled.button`
  background-color: ${(props) => (props.primary ? '#000000' : '#777777')};
  color: white;
  border: none;
  padding: 10px 20px;
  cursor: pointer;
`;
```

5. Глобальні стилі:
   Ви можете використовувати `createGlobalStyle` зі Styled Components для визначення глобальних стилів, які будуть застосовуватися до всього додатка.

Styled Components спрощує структурування та управління стилями у вашому проєкті, даючи змогу створювати компоненти, що включають у себе стилі та поведінку. Вона також забезпечує підтримку динамічних стилів і пропсів, що робить стилізацію компонентів більш гнучкою.

## Як передати дані з сервера на клієнт під час використання SSR у React?
[⬆ Повернутися до списку](#список-запитань)

Під час використання SSR (Server-Side Rendering) у React, дані можуть бути попередньо завантажені на сервері та передані клієнту для ініціалізації стану програми. Ось як це робиться:

1. Підготуйте сервер:
   Ваш сервер повинен мати можливість обробляти запити на серверний рендеринг і отримання даних. Для цього ви можете використовувати бібліотеки типу Express.js, Next.js або інші.

2. Завантажте дані на сервері:
   Під час обробки запиту на сервері ви можете завантажити дані з вашого API або іншого джерела даних. Ці дані будуть використані для ініціалізації стану на клієнті.

3. Передайте дані клієнту:
   Найпоширеніший спосіб передавання даних із сервера на клієнт - це вбудовування даних у HTML, що надсилається клієнту. Наприклад, ви можете використовувати `window.INITIAL_STATE` або якусь іншу глобальну змінну на клієнті, щоб зберегти дані.

4. Використовуйте дані на клієнті:
   Коли клієнтський код почне виконуватися, він може витягти передані дані з глобальної змінної та використати їх для ініціалізації стану програми.

Пример на Express.js:

```
import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';
import App from './App'; // Ваш компонент React
import fetchInitialData from './fetchInitialData'; // Функція для завантаження даних

const app = express();

app.get('/', async (req, res) => {
  try {
    const initialData = await fetchInitialData(); // Завантаження даних із сервера
    const appMarkup = renderToString(<App initialData={initialData} />);
    const html = `
      <html>
        <head>
          <title>SSR React App</title>
        </head>
        <body>
          <div id="root">${appMarkup}</div>
          <script>
            window.__INITIAL_DATA__ = ${JSON.stringify(initialData)};
          </script>
          <script src="bundle.js"></script>
        </body>
      </html>
    `;
    res.send(html);
  } catch (error) {
    console.error('Error during server rendering:', error);

    res.status(500).send('Internal Server Error');
  }
});

app.listen(3000, () => {
  console.log('Server is listening on port 3000');
});
```

На клієнті ви можете використовувати `window.__INITIAL_DATA__` для ініціалізації стану вашої програми переданими даними.

Не забудьте обробити помилки і подбати про безпеку під час передачі даних із сервера на клієнт.

## Які переваги та недоліки мають функціональні компоненти порівняно з компонентами класів?
[⬆ Повернутися до списку](#список-запитань)

Функціональні компоненти мають кілька переваг перед компонентами класів:

1. Простота і читабельність коду:
   Функціональні компоненти зазвичай записуються у вигляді звичайних функцій, що робить їхній код більш лаконічним і зрозумілим. Вони не вимагають успадкування і конструкторів, як класи.

2. Легше піддаються оптимізації:
   Функціональні компоненти дають змогу використовувати певні оптимізації, як-от мемоїзація, що може поліпшити продуктивність під час рендерингу.

3. Підтримка хуків (hooks):
   Функціональні компоненти можуть використовувати хуки, які надають зручніший спосіб керування станом і побічними ефектами.

4. Легше тестування:
   Функціональні компоненти можуть бути простішими для тестування завдяки своїй структурі та відсутності стану класів.

5. Тенденція розвитку:
   Більшість нових функцій і поліпшень у бібліотеках React та інших бібліотеках для інтерфейсів надаються спочатку для функціональних компонентів.

Однак у функціональних компонентів також є деякі недоліки:

1. Відсутність інкапсуляції:
   На відміну від класів, функціональні компоненти не можуть використовувати приватні методи або властивості без використання хуків або інших механізмів.

2. Складні стани:
   За наявності складних станів і складної логіки функціональні компоненти можуть стати заплутаними, особливо без правильного використання хуків.

3. Менша сумісність із деякими бібліотеками:
   Деякі сторонні бібліотеки та інструменти можуть передбачати використання класів і не завжди добре сумісні з функціональними компонентами.

4. Великі проекти:
   У великих проектах може бути складно підтримувати структуру функціональних компонентів без суворої організації коду.

Загалом, вибір між функціональними компонентами та компонентами класів залежить від конкретних вимог проєкту, структури команди розробників і особистих уподобань.

## Які особливості мають хуки `useEffect` та `useLayoutEffect`?
[⬆ Повернутися до списку](#список-запитань)

`useEffect` та `useLayoutEffect` - це два хуки в React, які дають змогу виконувати побічні ефекти у функціональних компонентах. Однак у них є деякі відмінності:

#### Час виконання:

`useEffect`: Цей хук виконує побічні ефекти після того, як браузер оновив екран (після того, як відбулося візуалізацію, і компонент відобразився на екрані). Він не блокує браузер і виконується асинхронно.

`useLayoutEffect`: Цей хук виконує побічні ефекти синхронно, одразу після завершення рендерингу компонента і перед відображенням змін на екрані. Він блокує браузер доти, доки всі ефекти не будуть виконані.

#### Використання:

Обидва хуки використовуються для виконання побічних ефектів, як-от надсилання мережевих запитів, підписка на події або зміна DOM.

Різниця полягає в тому, що якщо вам потрібно виконати дії, що залежать від макета (layout) до того, як користувач побачить оновлений інтерфейс, ви можете використовувати `useLayoutEffect`.

#### Рекомендації:

У більшості випадків краще використовувати `useEffect`, оскільки він не блокує браузер і зазвичай досить ефективний для більшості сценаріїв.

`useLayoutEffect` варто використовувати тоді, коли вам справді потрібно виконати побічні ефекти синхронно після рендерингу компонента.

Вибір між `useEffect` та `useLayoutEffect` залежить від конкретних вимог вашого додатка і часу, в який ви хочете, щоб ефекти виконалися.

## Як оновити стан компонента після виконання асинхронної операції?
[⬆ Повернутися до списку](#список-запитань)

Для оновлення стану компонента після виконання асинхронної операції в React, ви можете використовувати хук `useState` у поєднанні з хуком `useEffect`. Ось як це можна зробити:

#### 1) Імпортуйте необхідні хуки:

```
import React, { useState, useEffect } from 'react';
```

#### 2) Визначте компонент і його стан:

```
function MyComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // Виконання асинхронної операції (наприклад, запит на сервер)
    fetchData().then(result => {
      // Після виконання асинхронної операції оновіть стан
      setData(result);
    });
  }, []); // Порожній масив залежностей означає, що ефект виконається тільки один раз при монтуванні компонента

  return (
    <div>
      {data ? (
        <p>Дані: {data}</p>
      ) : (
        <p>Завантаження даних...</p>
      )}
    </div>
  );
}
```

#### 3) Зверніть увагу на залежність масиву в `useEffect`:

У прикладі вище ми передали порожній масив залежностей (`[]`) в `useEffect`. Це означає, що ефект буде виконано тільки один раз під час монтування компонента. Якщо ви хочете, щоб ефект виконався при зміні певних значень, додайте їх у масив залежностей. Наприклад:

```
useEffect(() => {
  // Виконання асинхронної операції, що залежить від якихось значень
  fetchData(someValue).then(result => {
    // Оновлення стану
    setData(result);
  });
}, [someValue]); // Залежність від someValue
```

Таким чином, після виконання асинхронної операції, коли дані доступні, стан компонента буде оновлено за допомогою функції `setData`, що призведе до перемальовування компонента з новими даними.

## Що таке CSS-in-JS, і які бібліотеки ви знаєте для реалізації цієї концепції в React?
[⬆ Повернутися до списку](#список-запитань)

**CSS-in-JS** - це підхід до стилізації веб-додатків, за якого стилі написані безпосередньо всередині компонентів на JavaScript. Це дає змогу пов'язати стилі з конкретними компонентами та створити більш модульний і передбачуваний код. Підхід CSS-in-JS активно використовується в екосистемі React, хоча концепція також може бути застосована і в інших фреймворках.

Нижче наведено деякі популярні бібліотеки для реалізації CSS-in-JS у React:

**1. Styled Components:**
Це одна з найпопулярніших бібліотек для CSS-in-JS. Вона дає змогу створювати компоненти, які містять у собі і стилі, і легко маніпулювати стилями за допомогою JavaScript.

**2. Emotion:**
Це потужна бібліотека для стилізації компонентів у React. Emotion надає різноманітні функції для створення стилів, включно з підтримкою глобальних стилів і медіа-запитів.

**3. Styled System:**
Це бібліотека, яка надає систему для створення дизайн-систем, заснованих на темах, які скористалися підходом CSS-in-JS.

**4. Radium:**
Ця бібліотека додає підтримку інлайн-стилів і псевдокласів у React. Вона також забезпечує автоматичну обробку префіксів і медіа-запитів.

**5. Glamorous:**
Це бібліотека, заснована на Styled Components, що надає зручний і декларативний спосіб створення стилів у компонентах.

**6. Fela:**
Це бібліотека з акцентом на продуктивність. Вона використовує функціональний підхід для визначення стилів.

**7. Linaria:**
Це інструмент, який дає змогу писати CSS усередині компонентів, але потім під час складання переносить їх в окремі CSS-правила для ефективнішого завантаження.

**8. Theme UI:**
Ця бібліотека, заснована на Emotion і Styled System, надає простий спосіб створення темізаціі і стилів у React-додатках.

Вибір бібліотеки залежить від ваших уподобань, вимог проекту і структури команди розробників. Кожна з цих бібліотек має свої унікальні особливості та переваги.

## Як реалізувати drag-and-drop функціональність у React-додатку?
[⬆ Повернутися до списку](#список-запитань)

Реалізація функціональності перетягування (drag-and-drop) у React-додатку може бути досягнута з використанням стандартних подій миші та стану компонентів React. Ось базовий підхід до створення такої функціональності:

1. Створення компонентів для перетягуваних і цільових елементів:
   Спочатку створіть компоненти для елементів, які ви хочете переміщати (елементи, що перетягуються) і елементів, на які ви хочете перетягнути (цільові області).

2. Керування станом:
   Додайте стан у компоненти, щоб відстежувати, перетягується в даний момент елемент чи ні. Наприклад, ви можете використовувати `useState` для цього.

3. Обробка подій:
   У компонентах елементів, що перетягуються, додайте обробники подій `onDragStart`, `onDrag`, та `onDragEnd`:

```
<div
  draggable
  onDragStart={(e) => handleDragStart(e, item)}
  onDrag={(e) => handleDrag(e)}
  onDragEnd={(e) => handleDragEnd(e)}
>
 {/* Вміст елемента, що перетягується */}
</div>
```

4. Реалізація функцій обробників:
   Створіть функції обробники для подій перетягування. У них ви будете оновлювати стан компонентів і маніпулювати даними про перетягуваний елемент.

5. Визначення областей для перетягування:
   У цільових компонентах визначте зони, на які можна кинути перетягуваний елемент. Додайте обробники подій `onDragOver` та `onDrop`:

```
<div
  onDragOver={(e) => handleDragOver(e)}
  onDrop={(e) => handleDrop(e, target)}
>
   {/* Вміст цільової області */}
</div>
```

6. Реалізація обробників для областей перетягування:
   Аналогічно створіть функції-обробники для подій `onDragOver` та `onDrop`, де ви запобігатимете стандартній поведінці браузера та оновлюватимете стан компонентів відповідно до дій користувача.

7. Оновлення стану:
   У функціях обробниках оновлюйте стан компонентів так, щоб відображати поточний стан перетягування.

8. Рендеринг компонентів:
   Не забудьте рендерити ваші компоненти в компоненті верхнього рівня, щоб створити інтерфейс перетягування.

Наведений вище підхід представляє базову концепцію реалізації drag-and-drop в React. У складніших випадках, наприклад, за необхідності підтримки перетягування між різними компонентами або списками, можливо, знадобиться використовувати додаткові бібліотеки або заглибитися в складніші патерни.

## Як реалізувати аутентифікацію та авторизацію в React-додатку?
[⬆ Повернутися до списку](#список-запитань)

Аутентифікація та авторизація - це важливі аспекти безпеки веб-додатків. Аутентифікація передбачає перевірку особистості користувача, тоді як авторизація керує доступом користувача до певних ресурсів або дій. Ось як це можна реалізувати в React-додатку:

#### 1) Аутентифікація:

Аутентифікація зазвичай включає в себе перевірку автентичності користувача, наприклад, з використанням пари логін-пароль або токена.

- Локальна автентифікація:
  Ви можете використовувати бібліотеки для управління автентифікацією, такі як `bcrypt` для хешування паролів. У разі успішної автентифікації створіть токен сесії або JWT (JSON Web Token), який буде використовуватися для подальших запитів.

- Сторонні сервіси:
  Для автентифікації через сторонні сервіси, як-от Google або Facebook, використовуйте бібліотеки, що надаються цими сервісами, щоб отримати токени доступу.

#### 2) Авторизація:

Авторизація визначає, які ресурси та дії доступні авторизованим користувачам.

- Роль і права:
  Створіть систему ролей і прав доступу для розмежування доступу. Це може бути реалізовано у вигляді бази даних з ролями і правами, пов'язаними з користувачами.

#### 3) Зберігання стану:

Для управління станом аутентифікації та авторизації, використовуйте **Context API** або бібліотеки управління станом, такі як **Redux**. Стан має містити інформацію про поточного користувача, його ролі та права, а також токена аутентифікації.

#### 4) Захист маршрутів:

Залежно від авторизації, ви можете захистити певні маршрути у вашому застосунку. Це можна зробити за допомогою високорівневих компонентів, що обгортають маршрути, які перевіряють наявність і відповідність прав доступу.

#### 5) Обробка запитів:

Під час виконання запитів до вашого сервера, включайте токен аутентифікації в заголовок `Authorization`, щоб сервер міг перевірити легітимність запиту.

#### 6) Розлогінювання:

Створіть механізм розлогінювання, який видалятиме дані автентифікації зі стану застосунку і, можливо, видалятиме токен із клієнтського сховища.

#### 7) Обробка помилок:

Під час реалізації аутентифікації та авторизації обов'язково передбачте обробку помилок, таких як недійсні токени або відсутність доступу.

#### 8) Безпека:

Обов'язково стежте за безпекою, зберігаючи токени в безпечних місцях (наприклад, HttpOnly cookies для токенів сесій) і забезпечуючи захищене з'єднання (HTTPS).

Це лише базовий огляд процесу реалізації аутентифікації та авторизації в React-додатку. Важливо також враховувати специфікації та рекомендації для безпеки у вашому контексті.

## Як працює маршрутизація на стороні клієнта в React?
[⬆ Повернутися до списку](#список-запитань)

Маршрутизація на стороні клієнта в React дає змогу створювати односторінкові додатки (SPA), де вміст змінюється без повного перезавантаження сторінки. Для цього використовується бібліотека маршрутизації, наприклад, `react-router`. Ось як це працює:

#### 1) Встановлення та налаштування react-router:

Спочатку встановіть `react-router-dom` за допомогою npm або yarn:

```
npm install react-router-dom
```

Потім ви можете налаштувати маршрути у вашому застосунку.

#### 2) Визначення маршрутів:

У вашому компоненті, що відповідає за маршрутизацію, визначте маршрути за допомогою компонента `Route`. Кожен `Route` може мати шлях і відповідний компонент, який буде відображатися при збігу маршруту.

```
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';

function App() {
  return (
    <Router>
      <Switch>
        <Route exact path="/" component={Home} />
        <Route path="/about" component={About} />
        <Route path="/contact" component={Contact} />
      </Switch>
    </Router>
  );
}
```

#### 3) Створення навігації:

Для переходу між різними маршрутами використовуйте компонент `Link` або `NavLink`. Ці компоненти створюють посилання, які оновлюють URL, але не виконують повне перезавантаження сторінки.

```
import { Link } from 'react-router-dom';

function Navigation() {
  return (
    <nav>
      <ul>
        <li>
          <Link to="/">Home</Link>
        </li>
        <li>
          <Link to="/about">About</Link>
        </li>
        <li>
          <Link to="/contact">Contact</Link>
        </li>
      </ul>
    </nav>
  );
}
```

#### 4) Динамічні параметри маршрутів:

Ви можете використовувати динамічні параметри в маршрутах, щоб обробляти різні значення в URL.

```
<Route path="/user/:id" component={UserProfile} />
```

У цьому прикладі, під час переходу на `/user/123`, компонент `UserProfile` відображатиметься з параметром `id`, що дорівнює `123`.

#### 5) Вкладені маршрути:

Маршрути можуть бути вкладеними, даючи змогу вам створювати складні структури маршрутизації для різних частин програми.

#### 6) Обробка 404:

Для відображення сторінки 404 (не знайдено), ви можете додати маршрут без вказівки path, який спрацьовуватиме в разі, якщо не знайдено збігів з іншими маршрутами.

```
<Route component={NotFound} />
```

Маршрутизація на стороні клієнта за допомогою `react-router` дає змогу створювати динамічніші та зручніші для користувачів інтерфейси, де контент оновлюється без перезавантаження всієї сторінки.

## Что такое "code splitting" (разделение кода) в React?
[⬆ Повернутися до списку](#список-запитань)

«Code splitting» (поділ коду) - це техніка оптимізації, яка використовується в React (і не тільки), щоб розділити великий JavaScript-файл на менші фрагменти (чанки), які завантажуються на вимогу. Це дає змогу поліпшити продуктивність і швидкодію веб-додатків.

У контексті React, поділ коду зазвичай відбувається під час створення збірки програми, і для цього використовується механізм динамічного імпорту. Замість того, щоб завантажувати весь JavaScript-код під час першого відкриття застосунку, ви можете розділити його на більш дрібні частини, які будуть завантажуватися тільки тоді, коли вони дійсно знадобляться.

#### Переваги «code splitting» у React:

1. Поліпшення продуктивності:
   Завантаження тільки необхідних частин коду прискорює початковий час завантаження програми та знижує обсяг переданих даних.

2. Оптимізація:
   Користувачі можуть завантажити тільки ті частини додатка, які їм необхідні, зменшуючи зайве навантаження на мережу і процесор.

3. Поділ сторінок:
   Кожна сторінка або компонент може бути розділена на окремі чанки, що дає змогу ефективніше використовувати ресурси.

4. Паралельне завантаження:
   Браузер може одночасно завантажувати кілька чанків, покращуючи загальний час завантаження.

Приклад динамічного імпорту з використанням «code splitting»:

```
import React, { lazy, Suspense } from 'react';

const DynamicComponent = lazy(() => import('./DynamicComponent'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <DynamicComponent />
      </Suspense>
    </div>
  );
}
```

У цьому прикладі, компонент `DynamicComponent` буде завантажуватися асинхронно тільки тоді, коли він дійсно потрібен.

## Как управлять состоянием между компонентами, не имеющими близкой связи?
[⬆ Повернутися до списку](#список-запитань)

Існує кілька методів для управління станом між компонентами, які не мають прямого зв'язку. Ось деякі з них:

#### 1) Підняття стану (Lifting State Up):

Ви можете підняти стан до найближчого спільного батьківського компонента, який має доступ і до одного, і до іншого компонента. Потім передавайте цей стан як пропси в кожен компонент. Цей підхід особливо корисний, коли компоненти мають спільний батьківський компонент, але не мають прямого зв'язку один з одним.

#### 2) Контекст (Context API):

Використовуйте Context API, який дає змогу передавати дані глибоко в дерево компонентів без явного передавання пропсів через усі рівні. Створіть контекст і оберніть ваше дерево компонентів цим контекстом. Таким чином, компоненти зможуть отримувати доступ до даних із контексту, навіть якщо вони не перебувають у прямій ієрархії.

#### 3) Глобальний стан (Global State):

Використовуйте бібліотеки управління станом, такі як Redux або MobX, щоб створити глобальне сховище даних, доступне для всіх компонентів. Це особливо корисно, якщо стан потрібен між компонентами, які знаходяться далеко один від одного в дереві компонентів.

#### 4) Подієва система:

Реалізуйте свою подієву систему, яка дозволить компонентам підписуватися на певні події та передавати дані. Це можна зробити за допомогою сторонніх бібліотек або самостійно.

#### 5) RESTful API:

Якщо ваші компоненти спілкуються із сервером, ви можете використовувати RESTful API для обміну даними між ними. Компоненти можуть отримувати та надсилати дані через API.

#### 6) Бібліотеки для управління станом:

Залежно від вашого досвіду і вимог, ви також можете розглянути використання бібліотек управління станом, таких як Recoil, Zustand та інших.

Вибір методу залежатиме від конкретних вимог вашого застосунку, його архітектури та складності взаємодії між компонентами.

## Які засоби надає React для тестування компонентів?
[⬆ Повернутися до списку](#список-запитань)

React надає кілька засобів і підходів для тестування компонентів. Ці засоби допомагають забезпечити стабільність і надійність вашого коду. Ось деякі з них:

#### 1) Jest:

Jest - це популярна бібліотека для тестування JavaScript-коду, включаючи компоненти React. Вона поставляється з Create React App за замовчуванням і надає функції для написання тестів, створення моків і затвердження (assertions).

#### 2) React Testing Library:

React Testing Library - це набір інструментів для тестування React-компонентів з упором на реальні сценарії використання. Він допомагає писати тести, які більше схожі на те, як користувачі будуть взаємодіяти з вашим додатком.

#### 3) Enzyme:

Enzyme - це інша популярна бібліотека для тестування React-компонентів. Вона надає зручні API для створення, маніпулювання та перевірки компонентів. Однак, зауважте, що Enzyme більш статичний і не так зосереджений на тестуванні сценаріїв використання, як React Testing Library.

#### 4) Snapshot тестування:

Snapshot тестування дає змогу порівнювати серіалізовані версії компонентів із попередніми збереженими знімками. Це допомагає швидко виявляти зміни в компонентах. Jest включає підтримку snapshot тестування.

#### 5) Інтеграційне тестування:

Ви можете використовувати тестові бібліотеки та інструменти, як-от Testing Library, для тестування взаємодії між компонентами та перевірки того, як вони взаємодіють разом.

#### 6) Mocking:

Під час тестування компонентів, які взаємодіють із зовнішніми залежностями (наприклад, API-запитами), ви можете використовувати моки (mocks) для заміни цих залежностей на керовані імітації.

#### 7) Тестування хуків (Hooks):

Хуки також можуть бути протестовані з використанням згаданих вище інструментів. React Testing Library і Jest мають підтримку для тестування хуків.

Загалом, React надає великі засоби для тестування компонентів різними способами. Вибір конкретного підходу залежить від ваших уподобань, архітектури застосунку та вимог до тестування.

## Як працює "ледаче завантаження" (lazy loading) компонентів у React?
[⬆ Повернутися до списку](#список-запитань)

"Ледаче завантаження" (lazy loading) - це техніка оптимізації, яка використовується в React, щоб відкласти завантаження компонентів доти, доки вони дійсно не знадобляться. Це допомагає прискорити початковий час завантаження застосунку, особливо коли застосунок має великий обсяг коду.

Для реалізації ледачого завантаження в React використовується динамічний імпорт - спеціальна можливість JavaScript, яка дає змогу завантажувати модулі на вимогу.

Приклад використання ледачого завантаження компонентів за допомогою динамічного імпорту:

```
import React, { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => import('./LazyComponent'));

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
```

У цьому прикладі, компонент `LazyComponent` буде завантажуватися асинхронно тільки тоді, коли він дійсно потрібен. Якщо компонент ще не завантажився, поки він не знадобиться, то буде показано компонент, вказаний у `fallback`.

Після компонентів ліниво завантажених через `lazy`, можна використовувати їх так само, як і інші компоненти.

#### Примітки:

- Ледаче завантаження працює в основному з компонентами, але також може бути застосоване до інших модулів JavaScript.
- Ледаче завантаження добре поєднується з "code splitting", даючи змогу розділяти і завантажувати тільки ті частини програми, які дійсно потрібні для поточного подання.
- Не рекомендується використовувати ледаче завантаження для всіх компонентів, оскільки це може призвести до надмірної складності. Натомість застосовуйте його там, де це дійсно виправдано з точки зору оптимізації.

## Що таке "синтетичні події" (synthetic events) у React?
[⬆ Повернутися до списку](#список-запитань)

У React, "синтетичні події" (synthetic events) - це система опрацювання подій, яка надає крос-браузерну та крос-платформну абстракцію над нативними подіями браузера. Вони створюються та керуються React і забезпечують більш однакову поведінку обробки подій у різних браузерах.

Синтетичні події надаються компонентам React як аргументи обробників подій і мають схожий інтерфейс із нативними подіями браузера, але з деякими відмінностями та поліпшеннями.

Приклад використання синтетичних подій:

```
import React from 'react';

class Button extends React.Component {
  handleClick = (event) => {
    event.preventDefault();
    console.log('Button clicked!');
  };

  render() {
    return <button onClick={this.handleClick}>Click me</button>;
  }
}
```

У цьому прикладі `event` є синтетичною подією, що передається в обробник `handleClick`. Ви можете викликати методи такі як `preventDefault()`, `stopPropagation()`, та інші, а також отримувати інформацію про подію (наприклад, `event.target`, `event.clientX`, та ін.).

Синтетичні події також мають додаткові переваги, такі як автоматичний пулінг (для оптимізації роботи з пам'яттю), нормалізація відмінностей між різними браузерами і підтримка делегування подій.

## Як організувати перевикористання компонентів у React?
[⬆ Повернутися до списку](#список-запитань)

Перевикористання компонентів - один з основних принципів розробки в React. Це дає змогу створювати ефективний і легко підтримуваний код. Ось деякі методи організації перевикористання компонентів:

#### 1) Компоненти вищого порядку (HOC):

Створення компонентів вищого порядку дозволяє обертати інші компоненти, додаючи їм певну поведінку. Це корисно для ізоляції логіки, яку ви хочете застосувати до кількох компонентів.

#### 2) Композиція компонентів:

Будувати складніші компоненти шляхом комбінування простіших. Компоненти, які представляють більш загальні елементи (наприклад, кнопки, картки тощо), можуть бути повторно використані та налаштовані залежно від конкретних потреб.

#### 3) Render Props:

Створення компонентів, які передають функцію через властивість children або іншу певну властивість. Це дає змогу іншим компонентам використовувати цю функцію для впровадження свого контенту.

#### 4) Хуки (Hooks):

З React 16.8, хуки дозволили перевикористовувати стан і логіку у функціональних компонентах без використання класів. Вам навіть можна створювати власні користувацькі хуки для ізоляції певної функціональності.

#### 5) Бібліотеки компонентів:

Існує безліч бібліотек компонентів, як-от Material-UI, Ant Design, Chakra UI та інші, що надають готові компоненти для перевикористання у ваших проєктах.

#### 6) Компоненти сторінок (Page Components) і компоненти макета (Layout Components):

Поділ компонентів на ті, що відповідають за макет (навігація, бічна панель тощо) і ті, що відповідають за конкретний вміст сторінки, може істотно підвищити перевикористання.

#### 7) Контейнери та компоненти представлення (Containers and Presentational Components):

Поділяйте компоненти на "розумні" контейнери, які керують станом і бізнес-логікою, і "дурні" компоненти представлення, які відображають дані, передані їм із контейнерів.

Дотримуючись цих методів, ви зможете організувати ефективне перевикористання компонентів у вашому додатку, що спростить підтримку коду і прискорить розробку.

## Що таке "високонавантажені компоненти" (high-order components) і як їх створити?
[⬆ Повернутися до списку](#список-запитань)

**"Високонавантажені компоненти"** (High-Order Components, HOC) - це патерн у React, який дає змогу ізолювати та повторно використовувати логіку компонентів. HOC не є частиною синтаксису React, це скоріше патерн, що використовує наявні механізми мови для створення нових компонентів.

HOC дають змогу додавати або змінювати функціональність компонентів, обертаючи їх в інші компоненти. Це часто використовується для винесення загальної логіки, такої як обробка автентифікації, логування тощо, щоб ізолювати цю логіку і забезпечити її перевикористання.

Приклад створення HOC:

```
import React from 'react';

// HOC приймає компонент WrappedComponent як аргумент
const withLogger = (WrappedComponent) => {
  // Новий компонент, що повертається HOC
  class WithLogger extends React.Component {
    componentDidMount() {
      console.log(`Component ${WrappedComponent.name} mounted`);
    }

    render() {
      // Прокидаємо пропси в обгорнутий компонент
      return <WrappedComponent {...this.props} />;
    }
  }

  return WithLogger;
};

// Використовуємо HOC для обертання іншого компонента
const MyComponent = (props) => <div>Привіт, світ!</div>;
const ComponentWithLogger = withLogger(MyComponent);

export default ComponentWithLogger;
```

У цьому прикладі `withLogger` - це HOC, який обертає компонент `MyComponent`. Коли `ComponentWithLogger` рендериться, він додає логіку для виведення повідомлення про монтування компонента в консоль.

Для використання HOC:

```
import React from 'react';
import ComponentWithLogger from './ComponentWithLogger';

function App() {
  return (
    <div>
      <ComponentWithLogger />
    </div>
  );
}
```

HOC - це потужний інструмент для повторного використання логіки та обгортання компонентів у загальну функціональність. Однак вони також мають свої обмеження і можуть ускладнити структуру коду, тому їх слід використовувати з розумом.

## Какие принципы следует соблюдать при именовании компонентов в React?
[⬆ Повернутися до списку](#список-запитань)

Іменування компонентів у React відіграє важливу роль у читабельності, розумінні структури застосунку та його логіки. Дотримання хороших практик з іменування допомагає зробити код більш зрозумілим і підтримуваним. Ось деякі принципи, яких слід дотримуватися під час іменування компонентів:

#### 1) Використовуйте ясне й описове ім'я:

Ім'я компонента має чітко відображати його призначення та функціональність. Уникайте скорочень і абревіатур, які можуть бути незрозумілими іншим розробникам.

#### 2) Використовуйте PascalCase:

Імена компонентів слід писати в PascalCase (усі слова починаються із великої літери), щоб їх легко було відрізнити від звичайних HTML-тегів і змінних.

#### 3) Уникайте конфліктів з HTML-тегами:

Ім'я компонента не повинно збігатися з ім'ям наявних HTML-тегів, щоб не викликати плутанину.

#### 4) Використовуйте чіткі імена для пропсів:

Якщо ви передаєте пропси компоненту, їхні імена також мають бути ясними та описовими. Це допоможе іншим розробникам зрозуміти, які дані очікуються.

#### 5) Дотримуйтесь конвенцій вашого проєкту:

Якщо у вас є певні стандарти іменування у вашому проєкті або команді, дотримуйтесь їх. Це допоможе підтримувати структуру коду в єдиному стилі.

#### 6) Ім'я файлу та ім'я компонента мають збігатися:

Зберігайте ім'я файлу, що містить компонент, таким самим, як і ім'я самого компонента. Це робить простіше знайти і пов'язати компонент з його файлом.

Приклад гарного іменування:

```
// Погано
const C = () => {...}

// Добре
const UserProfile = () => {...}

// Передача пропсів: Добре
const UserProfile = ({ username, avatar }) => {...}
```

Дотримання цих принципів під час іменування компонентів допоможе зробити ваш код більш читабельним, зрозумілим і зручним для супроводу.

## Як реалізувати анімацію переходів між компонентами в React Router?
[⬆ Повернутися до списку](#список-запитань)

Для реалізації анімації переходів між компонентами під час використання React Router, ви можете скористатися різними підходами та бібліотеками. Ось один із підходів, використовуючи CSS-транзиції та бібліотеку `react-transition-group`.

#### 1) Встановлення залежностей:

Встановіть бібліотеку `react-transition-group` за допомогою npm або yarn:

```
npm install react-transition-group
```

#### 2) Створення компонентів анімації:

Створіть компоненти, які керуватимуть анімацією входу і виходу. Наприклад, `FadeIn` і `FadeOut`.

```
import React from 'react';
import { CSSTransition } from 'react-transition-group';
import './FadeTransition.css'; // Підключіть стилі для анімації

const FadeTransition = ({ children, ...props }) => (
  <CSSTransition
    {...props}
    timeout={500}
    classNames="fade"
  >
    {children}
  </CSSTransition>
);

export default FadeTransition;
```

#### 3) Створення CSS-транзицій:

У папці вашого проєкту створіть файл `FadeTransition.css` і визначте стилі для анімації:

```
.fade-enter {
  opacity: 0;
}

.fade-enter-active {
  opacity: 1;
  transition: opacity 500ms ease-in;
}

.fade-exit {
  opacity: 1;
}

.fade-exit-active {
  opacity: 0;
  transition: opacity 500ms ease-out;
}
```

#### 4) Використання анімації:

У вашому компоненті, де ви використовуєте R`eact Router`, оберніть маршрут у компонент `FadeTransition`:

```
import React from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';
import FadeTransition from './FadeTransition';
import Home from './Home';
import About from './About';

const App = () => {
  return (
    <Router>
      <Switch>
        <Route path="/about">
          <FadeTransition>
            <About />
          </FadeTransition>
        </Route>
        <Route path="/">
          <FadeTransition>
            <Home />
          </FadeTransition>
        </Route>
      </Switch>
    </Router>
  );
};

export default App;
```

У цьому прикладі під час переходу між маршрутами компоненти з'являтимуться і зникатимуть з анімацією.

Зверніть увагу, що це лише один зі способів реалізації анімації переходів. Існують й інші бібліотеки, як-от `framer-motion` та `react-router-transitions`, які також можуть допомогти в реалізації анімацій між компонентами під час використання React Router.

## Що таке "глибоке перенесення стану" (deep state transfer) у React?
[⬆ Повернутися до списку](#список-запитань)

"Глибоке перенесення стану" - це патерн, який використовується для передачі стану або даних через кілька компонентів в ієрархії React без використання проміжних пропсів. Це може статися, коли компоненти, що знаходяться далеко один від одного в ієрархії, повинні обмінюватися даними.

Однак глибоке перенесення стану може стати проблемою з погляду читабельності коду та обслуговуваності. Кожен проміжний компонент у ланцюжку має передавати пропси, навіть якщо він сам не використовує їх. Це може призвести до заплутаного коду і ускладнення процесу налагодження та підтримки.

Замість глибокого перенесення стану рекомендується використовувати більш спеціалізовані патерни управління станом, такі як:

1. **Контекст (Context): **
   Контекст у React дає змогу передавати дані вниз по ієрархії компонентів без явної передачі пропсів через кожен проміжний компонент. Однак його слід використовувати обережно, щоб уникнути створення "глобального стану" і не надмірно ускладнити код.

2. **Хуки управління станом (State Management Hooks): **
   Замість глибокого перенесення стану, ви можете використовувати спеціалізовані бібліотеки управління станом, такі як Redux, MobX, Recoil та інші. Вони надають більш структурований і керований спосіб обміну даними між компонентами.

3. **Переміщення логіки в батьківський компонент: **
   Якщо компоненти використовують спільну логіку або дані, спробуйте перемістити цю логіку або дані до спільного батьківського компонента. Це дасть змогу уникнути глибокого перенесення стану.

Важливо знаходити баланс між передачею даних через пропси та використанням спеціалізованих методів управління станом. Використовуйте той патерн, який найбільше підходить для конкретної ситуації, щоб забезпечити читабельність, підтримуваність і ефективність вашого коду.

## Як реалізувати модальне вікно в React-додатку?
[⬆ Повернутися до списку](#список-запитань)

Реалізація модального вікна в React-додатку може бути виконана різними способами. Ось один зі способів, використовуючи стан і стилі:

#### 1) Створення компонента модального вікна:

Створіть компонент для модального вікна, який буде керувати його відображенням і змістом.

```
import React from 'react';

const Modal = ({ isOpen, onClose, children }) => {
  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal">
        <button className="modal-close" onClick={onClose}>Закрити</button>
        {children}
      </div>
    </div>
  );
};

export default Modal;
```

#### 2) Створення стилів для модального вікна:

Створіть стилі для модального вікна за допомогою CSS або будь-якого CSS-препроцесора.

```
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
}

.modal {
  background-color: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.2);
}

.modal-close {
  position: absolute;
  top: 10px;
  right: 10px;
}
```

#### 3) Використання модального вікна:

Використовуйте створений компонент модального вікна у вашому додатку.

```
import React, { useState } from 'react';
import Modal from './Modal';

const App = () => {
  const [isModalOpen, setModalOpen] = useState(false);

  const openModal = () => setModalOpen(true);
  const closeModal = () => setModalOpen(false);

  return (
    <div>
      <button onClick={openModal}>Відкрити модальне вікно</button>
      <Modal isOpen={isModalOpen} onClose={closeModal}>
        <h2>Модальне вікно</h2>
        <p>Вміст модального вікна...</p>
      </Modal>
    </div>
  );
};

export default App;
```

Це базовий приклад реалізації модального вікна в React-додатку. Ви можете налаштувати його дизайн і поведінку залежно від ваших вимог. Для більш складних сценаріїв і анімацій також можуть знадобитися додаткові бібліотеки або підходи.

## Що таке SSR (Server-Side Rendering) і навіщо його використовувати?
[⬆ Повернутися до списку](#список-запитань)

Server-Side Rendering (SSR), або рендеринг на стороні сервера, - це техніка, за якої HTML-контент генерується на сервері та надсилається клієнту (браузеру), на відміну від традиційного клієнтського рендерінгу (CSR), де HTML генерується на клієнтській стороні з використанням JavaScript.

#### Під час використання SSR:

**1) Ініціальне завантаження швидше: **
Користувачі бачать контент швидше, оскільки сервер відправляє повністю готову для відображення сторінку. Це особливо важливо для поліпшення початкового часу завантаження, що може підвищити задоволеність користувачів і поліпшити показники SEO.

**2) SEO-оптимізація: **
Пошукові системи можуть більш ефективно індексувати і ранжувати сторінки з повністю відмальованим контентом на сервері, що може поліпшити видимість вашого сайту в результатах пошуку.

**3) Поліпшення доступності та SEO: **
Для користувачів з повільним інтернетом або обмеженими можливостями браузера, SSR може забезпечити кращий досвід використання, оскільки вони будуть бачити контент раніше.

**4) Безпека: **
SSR може допомогти у зменшенні можливості атак на кшталт Cross-Site Scripting (XSS), оскільки сервер може краще контролювати та обробляти вхідні дані.

**5) Підтримка соціальних медіа: **
Коли контент рендериться на сервері, соціальні мережі та месенджери (наприклад, Facebook і Twitter) можуть легко витягувати дані для відображення прев'ю посилань.

**6) Корисно для динамічних даних: **
Навіть якщо ваш застосунок загалом є SPA (Single Page Application), SSR можна використовувати для візуалізації частин сторінки, що містять динамічні дані, які змінюються рідко.

Однак SSR також має свої складнощі, як-от управління станом і більш високе навантаження на сервер. Залежно від вашого проєкту та потреб, ви можете обирати між SSR і CSR або навіть комбінувати їх в одному застосунку для досягнення найкращого балансу між продуктивністю, SEO та досвідом користувачів.

## Які переваги дає використання CSS-модулів (CSS Modules)?
[⬆ Повернутися до списку](#список-запитань)

CSS-модулі - це підхід до стилізації компонентів у React та інших фронтенд-фреймворках, який дає змогу ізолювати стилі компонентів і уникати глобальних конфліктів імен класів. Ось деякі переваги використання CSS-модулів:

1. **Ізоляція стилів:**
   Кожен компонент має свої унікальні класи, що забезпечує повну ізоляцію стилів між компонентами. Це дає змогу уникати несподіваних перевизначень стилів і глобальних конфліктів.

2. **Локальні імена класів: **
   Імена класів автоматично генеруються з використанням унікальних ідентифікаторів для кожного компонента. Це знижує ймовірність колізій і дає змогу вам використовувати коротші та зрозуміліші імена класів.

3. **Читабельність і розуміння: **
   Стилі безпосередньо пов'язані з компонентами, що робить код більш читабельним і легко зрозумілим. Ви можете бачити, які стилі застосовуються до конкретного компонента, не досліджуючи весь файл стилів.

4. **Підтримка перевикористання: **
   Використовуючи CSS-модулі, ви можете створювати стилі, специфічні для компонента, і легко переносити або повторно використовувати ці компоненти в інших проєктах, не турбуючись про конфлікти стилів.

5. **Зменшення розміру файлу стилів: **
   Оскільки CSS-модулі генерують унікальні імена класів для кожного компонента, ви можете використовувати короткі імена класів без побоювання назв класів у глобальному контексті, що допомагає зменшити розмір файлу стилів.

6. ** Декларативність: **
   Ваш CSS залишається близьким до вашого компонента, що дає змогу вам використовувати більш декларативний та інтуїтивний підхід до стилізації.

7. ** Легка міграція: **
   Якщо у вас уже є проєкт зі стилями, використання CSS-модулів дає змогу поступово впроваджувати ізоляцію стилів, не вимагаючи одразу ж переписувати всі стилі.

CSS-модулі можуть бути особливо корисними у великих проєктах, де структура компонентів і стилів складна. Однак, як і з будь-якою технологією, важливо оцінити її застосовність у вашому конкретному випадку і переконатися, що вона відповідає вашим потребам.

## Що таке "віртуалізація списку" (list virtualization) і як вона реалізується в React?
[⬆ Повернутися до списку](#список-запитань)

Віртуалізація списку - це техніка оптимізації відображення великих списків елементів у користувацькому інтерфейсі. Коли у вас є великий набір даних, наприклад, список повідомлень, записів або товарів, звичайний рендеринг усіх елементів одразу може викликати проблеми з продуктивністю. Віртуалізація списку дає змогу рендерити тільки видимі елементи, що покращує продуктивність і економить пам'ять.

У React віртуалізація списку зазвичай реалізується з використанням двох основних бібліотек: react-virtualized і react-window. Ось як це працює:

#### react-virtualized:

`react-virtualized` надає компоненти для віртуалізації списку, такі як `List` та `Grid`. Він слідкує за прокруткою та рендерить лише ті елементи, які знаходяться в межах видимої області. Це дає змогу зменшити кількість намальованих елементів і поліпшити продуктивність.

Приклад використання `List` з `react-virtualized`:

```
import React from 'react';
import { List } from 'react-virtualized';

const MyList = ({ items }) => {
  const rowRenderer = ({ index, key, style }) => (
    <div key={key} style={style}>
      {items[index]}
    </div>
  );

  return (
    <List
      width={300}
      height={400}
      rowCount={items.length}
      rowHeight={30}
      rowRenderer={rowRenderer}
    />
  );
};

export default MyList;
```

#### react-window:

`react-window` надає більш легковагі компоненти для віртуалізації. Він розбиває список на більш дрібні фрагменти, що дозволяє знизити накладні витрати на пам'ять і продуктивність.

Приклад використання `FixedSizeList` з `react-window`:

```
import React from 'react';
import { FixedSizeList } from 'react-window';

const MyList = ({ items }) => {
  const rowRenderer = ({ index, style }) => (
    <div style={style}>
      {items[index]}
    </div>
  );

  return (
    <FixedSizeList
      height={400}
      width={300}
      itemCount={items.length}
      itemSize={30}
    >
      {rowRenderer}
    </FixedSizeList>
  );
};

export default MyList;
```

Обидві бібліотеки дають змогу ефективно рендерити великі списки елементів і значно поліпшити продуктивність вашого React-додатку. Вибір між `react-virtualized` та `react-window` залежить від ваших конкретних вимог і переваг.

## Як реалізувати include компонентів у React?
[⬆ Повернутися до списку](#список-запитань)

У React, включення компонентів можна здійснити за допомогою використання інших компонентів всередині батьківських компонентів. Це робиться шляхом вставки тега компонента в JSX коді батьківського компонента.

Приклад:

```
import React from 'react';

// Припустимо, у нас є компонент ChildComponent
const ChildComponent = () => {
  return <p>Це дочірній компонент</p>;
};

// Потім ми можемо використовувати ChildComponent всередині ParentComponent
const ParentComponent = () => {
  return (
    <div>
      <h1>Батьківський компонент</h1>
      <ChildComponent /> {/* Включення дочірнього компонента */}
    </div>
  );
};

export default ParentComponent;
```

У цьому прикладі `ChildComponent` включається всередині `ParentComponent` шляхом використання `<ChildComponent />`.

## Що таке "консиліація" (reconciliation) у контексті React?
[⬆ Повернутися до списку](#список-запитань)

**"Консиліація"** (reconciliation) у React - це процес порівняння попереднього дерева елементів (Virtual DOM) із новим деревом елементів, створеним унаслідок оновлення стану або пропсів компонентів.

У процесі роботи React-додатку компоненти можуть змінювати свої дані, стан і властивості. Коли це відбувається, React повинен оновити користувацький інтерфейс, щоб відобразити ці зміни. Консиліація - це механізм, який дає змогу React ефективно визначити, які частини DOM дійсно потрібно змінити.

Під час консиліації React використовує алгоритм порівняння двох дерев елементів - старого і нового. Він порівнює кожен елемент і його дітей, визначаючи, які зміни потрібно внести в реальному DOM для того, щоб відобразити новий стан компонента.

React прагне мінімізувати кількість реальних змін у DOM. Замість повного перемальовування він намагається знайти оптимальний спосіб оновлення, додавання і видалення елементів. Це дає змогу досягти ефективнішої роботи під час оновлень користувацького інтерфейсу.

## Як обробляти форми в React?
[⬆ Повернутися до списку](#список-запитань)

Обробка форм у React передбачає збір даних, введених користувачем у поля форми, і виконання певних дій на основі цих даних. Ось загальні кроки з обробки форм у React:

1. Створення компонента форми: Створіть компонент, який буде містити вашу форму. У цьому компоненті ви визначаєте поля введення та елементи керування (кнопки тощо).

2. Стан для даних форми: Використовуйте хук `useState` або класовий компонент для створення стану, у якому зберігатимуться дані, введені користувачем у форму.

3. Обробники подій: Створіть обробники подій, які викликатимуться при зміні значень полів введення або при відправленні форми. Ці обробники будуть оновлювати стан даних форми.

4. Зв'язування даних: Прив'яжіть значення полів введення до стану даних форми. Для компонентів класів використовуйте атрибут `value`, для функціональних компонентів - зв'язування через стан і обробники.

5. Надсилання даних: Під час надсилання форми викликайте обробник події, який виконуватиме необхідні дії з даними, наприклад, надсилання на сервер або виконання інших операцій.

Приклад обробки простої форми в React:

```
import React, { useState } from 'react';

const FormExample = () => {
  const [formData, setFormData] = useState({
    username: '',
    password: '',
  });

  const handleChange = (event) => {
    const { name, value } = event.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    // Тут можна виконати дії з даними форми, наприклад, відправити на сервер
    console.log(formData);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        name="username"
        value={formData.username}
        onChange={handleChange}
        placeholder="Ім'я користувача"
      />
      <input
        type="password"
        name="password"
        value={formData.password}
        onChange={handleChange}
        placeholder="Пароль"
      />
      <button type="submit">Надіслати</button>
    </form>
  );
};

export default FormExample;
```

Цей приклад демонструє, як створити просту форму в React, пов'язати її поля зі станом і обробляти введені дані.

## Альтернативи Redux для керування станом у React-додатках
[⬆ Повернутися до списку](#список-запитань)

На додаток до Redux, існує кілька інших бібліотек і підходів для управління станом у React-додатках. Ось деякі з них:

1. **React Context API**: Це вбудований механізм у React, який дає змогу передавати дані «вниз» по дереву компонентів, не вимагаючи необхідності явно передавати пропси через проміжні компоненти. Context API можна використовувати для створення глобального стану, але він може стати незручним при управлінні великим обсягом даних або складними взаємозв'язками.

2. **MobX**: Це бібліотека для управління станом, яка дозволяє робити відстеження змін і автоматично оновлювати компоненти при зміні стану. MobX більше дозволяє більш декларативно визначати стан і його залежності.

3. **Recoil**: Це бібліотека, розроблена Facebook, призначена для управління станом у React-додатках. Вона надає більш гнучкий спосіб роботи зі станом, підтримуючи атоми (невеликі одиниці стану) і селектори (функції для отримання даних з атомів).

4. **Zustand**: Це невелика бібліотека для управління станом, яка підтримує глобальний стан з використанням хуків. Вона полегшує створення та оновлення стану з мінімальним синтаксисом.

5. **Apollo Client**: Якщо ваш додаток пов'язаний з роботою з GraphQL-сервером, Apollo Client може бути корисним. Він не тільки керує станом, а й управляє даними, отриманими з сервера, і забезпечує зручні засоби для роботи із запитами і мутаціями.

Вибір конкретної альтернативи залежатиме від специфіки вашого проєкту, складності управління станом, особистих уподобань і командної експертизи.

## Як працює «гаряча заміна модулів» (Hot Module Replacement) у середовищі розробки React-додатків?
[⬆ Повернутися до списку](#список-запитань)

«Гаряча заміна модулів» (HMR) - це механізм, що дає змогу розробникам вносити зміни до коду застосунку в реальному часі, без повного перезавантаження сторінки або застосунку. Це особливо корисно під час розробки, оскільки дає змогу миттєво бачити результати внесених змін без затримок.

У контексті React-додатків, HMR забезпечує швидку заміну компонентів та інших модулів без перезавантаження всього додатка. Ось як це працює:

1. **Відстеження змін:** Під час запуску програми з HMR, інструменти розробки моніторять зміни у файлах компонентів та інших модулів.

2. **Виділення змін:** Коли розробник вносить зміни в коді (наприклад, усередині компонента), HMR виділяє тільки ті модулі, які були змінені.

3. **Застосування змін:** Замість повного перезавантаження сторінки або додатка, HMR застосовує тільки змінені модулі під час виконання. Це може включати заміну компонентів, оновлення стилів та інші зміни.

4. **Збереження стану:** Однією з важливих рис HMR є те, що він намагається зберегти стан програми після внесення змін. Наприклад, якщо ви вносите зміни до коду компонента, стан цього компонента зберігається, і ви не втрачаєте дані, які були введені або відображені.

5. **Оновлення інтерфейсу:** Після застосування змін, оновлюється тільки та частина інтерфейсу, яка дійсно змінилася. Це дає змогу вам миттєво бачити результати змін без видимих перемальовок або перезавантажень.

Використання HMR робить процес розробки ефективнішим і швидшим, оскільки розробникам не потрібно постійно перезавантажувати сторінку для перегляду результатів своїх змін. Цей механізм інтегрований у багато інструментів розробки, як-от webpack і Create React App, і дає змогу значно прискорити та полегшити процес розробки React-додатків.

## Що таке «мемоізація» (memoization) і як вона може бути застосована в React?
[⬆ Повернутися до списку](#список-запитань)

**Мемоїзація** - це оптимізаційна техніка, яка полягає у збереженні результатів виконання функції з певними аргументами та поверненні закешованого результату при повторних викликах функції з тими самими аргументами, замість повторного виконання функції. Це дає змогу уникнути зайвих обчислень і прискорити виконання коду.

У контексті React мемоїзація може бути застосована для оптимізації перемальовок компонентів. Компоненти в React перемальовуються, коли їхній стан або пропси змінюються. Однак у деяких випадках перемальовування може бути зайвим і спричинити втрату продуктивності. Тут мемоїзація приходить на допомогу.

У React використовується два основних інструменти для мемоїзації:

#### React.memo

Це високорівнева функція-обгортка, яку можна застосувати до функціональних компонентів. Вона дозволяє автоматично мемоїзувати компонент і запобігати його перемальовуванню, якщо його пропси залишилися незмінними.

Приклад:

```
import React from 'react';

const MyComponent = React.memo(({ prop1, prop2 }) => {
  // Компонент буде перемальований тільки при зміні prop1 або prop2
  return (
    <div>
      {/* Ваш код компонента */}
    </div>
  );
});
```

#### useMemo і useCallback:

Це хуки, які дають змогу мемоїзувати значення і колбеки всередині функціональних компонентів.

Приклад з `useMemo`:

```
import React, { useMemo } from 'react';

const MyComponent = ({ data }) => {
  const processedData = useMemo(() => {
    // Виконання дорогої операції на основі data
    return processData(data);
  }, [data]);

  return (
    <div>
      {/* Використання processedData */}
    </div>
  );
};
```

Мемоїзація корисна в тих випадках, коли компоненти мають дорогі обчислення або відтворення, і ви хочете мінімізувати їхнє перемальовування за незначних змін. Однак варто використовувати мемоїзацію усвідомлено, оскільки вона може підвищити складність коду і не завжди дає помітний ефект у продуктивності.

## Як реалізувати зв'язування даних (data binding) у React?
[⬆ Повернутися до списку](#список-запитань)

Зв'язування даних у React можна реалізувати за допомогою керованих компонентів. Керований компонент - це компонент, значення якого контролюються станом React і оновлюються через обробники подій. Для створення зв'язку між даними та компонентом можна використовувати такі кроки:

1. **Створення стану:** усередині компонента визначте стан, який міститиме дані для зв'язування.

2. **Зв'язування з елементами форм:** прив'яжіть значення елементів форм (наприклад, input, textarea) до стану компонента, встановлюючи атрибут `value` елемента рівним значенню зі стану та додаючи обробник змін для оновлення стану під час введення даних.

3. **Оброблювачі подій:** Визначте функції-оброблювачі, які будуть викликатися при зміні елементів форм. У цих функціях оновлюйте стан компонента з новими значеннями.

Приклад:

```
import React, { Component } from 'react';

class DataBindingExample extends Component {
  constructor(props) {
    super(props);
    this.state = {
      inputValue: '',
    };
  }

  handleInputChange = (event) => {
    this.setState({ inputValue: event.target.value });
  }

  render() {
    return (
      <div>
        <input
          type="text"
          value={this.state.inputValue}
          onChange={this.handleInputChange}
        />
        <p>Введене значення: {this.state.inputValue}</p>
      </div>
    );
  }
}

export default DataBindingExample;
```

Цей приклад демонструє керований компонент, у якому значення input прив'язане до стану компонента. При введенні даних у поле введення, стан оновлюється, і нове значення відображається під полем введення.

## Що таке «передача даних через контекст» (context passing) у React?
[⬆ Повернутися до списку](#список-запитань)

Передача даних через контекст (context passing) у React - це механізм, який дає змогу передавати дані глибоко в ієрархію компонентів без явного передавання пропсів через кожен проміжний компонент. Це особливо корисно, коли кілька компонентів у застосунку потребують доступу до одних і тих самих даних, як-от стан, тема оформлення або дані аутентифікації.

Контекст являє собою спосіб створення загального «контексту» даних, який можна використовувати всередині дочірніх компонентів, не передаючи дані явно через пропси.

Основні кроки для використання контексту:

1. **Створення контексту: **На початку ієрархії компонентів створюється контекст за допомогою функції `React.createContext()`. Ця функція повертає об'єкт контексту, який включає в себе Provider (постачальник) і Consumer (споживач).

2. **Постачальник (Provider): **Компонент, створений з використанням контексту, діє як постачальник даних. Він обертає всі дочірні компоненти, яким потрібен доступ до даних із контексту. Шляхом передачі значень через атрибути `value` Provider робить дані доступними для дочірніх компонентів.

3. **Споживач (Consumer):** Компоненти, яким потрібен доступ до даних контексту, обертаються в Consumer. Вони можуть отримати доступ до даних, переданих через Provider, використовуючи функцію-рендер-пропс, яка отримує поточне значення контексту.

Приклад використання контексту:

```
import React, { createContext, useContext } from 'react';

// Створення контексту
const ThemeContext = createContext();

// Компонент-постачальник
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Toolbar />
    </ThemeContext.Provider>
  );
}

// Компонент-споживач
function Toolbar() {
  const theme = useContext(ThemeContext);
  return <div>Тема: {theme}</div>;
}

export default App;
```

У цьому прикладі компонент `Toolbar` отримує доступ до значення теми, переданої через контекст від компонента `App`, без явної передачі через пропси.

## Як реалізувати перетягування (drag-and-drop) елементів у React-додатку?
[⬆ Повернутися до списку](#список-запитань)

Для реалізації перетягування елементів у React-додатку ви можете використовувати нативні події браузера в поєднанні зі станом компонентів React. Ось базові кроки, як це можна зробити:

#### 1) Створення компонентів:

- Створіть компоненти, які ви плануєте переміщувати.
- Визначте обробники подій для початку і завершення перетягування.

#### 2) Управління станом:

Створіть стан, який зберігатиме інформацію про перетягуваний елемент, його початкові координати тощо.

#### 3) Додавання обробників подій:

- Додайте обробник події `onDragStart` для елемента, який буде перетягуватися. У цьому обробнику встановіть дані про елемент, що перетягується, у стан, використовуючи функцію `setData` та `event.dataTransfer`.
- Додайте обробники `onDragOver` та `onDrop` для контейнера, куди ви збираєтеся переміщати елементи. В обробнику `onDragOver` запобігайте дії за замовчуванням, щоб дозволити перетягування, і в обробнику `onDrop` обробіть перетягування елемента.

Приклад:

```
import React, { useState } from 'react';

function DraggableElement({ text }) {
  const handleDragStart = (event) => {
    event.dataTransfer.setData('text/plain', text);
  };

  return (
    <div
      draggable
      onDragStart={handleDragStart}
      className="draggable-element"
    >
      {text}
    </div>
  );
}

function DroppableArea() {
  const [droppedItems, setDroppedItems] = useState([]);

  const handleDragOver = (event) => {
    event.preventDefault();
  };

  const handleDrop = (event) => {
    event.preventDefault();
    const droppedText = event.dataTransfer.getData('text/plain');
    setDroppedItems([...droppedItems, droppedText]);
  };

  return (
    <div
      className="droppable-area"
      onDragOver={handleDragOver}
      onDrop={handleDrop}
    >
      {droppedItems.map((item, index) => (
        <div key={index}>{item}</div>
      ))}
    </div>
  );
}

function App() {
  return (
    <div className="app">
      <DraggableElement text="Перетягни мене!" />
      <DroppableArea />
    </div>
  );
}

export default App;
```

Це базовий приклад реалізації перетягування елементів у React. Ви можете доповнити його стилями і додатковими функціями для поліпшення користувацького досвіду.

## Що таке «обчислювані властивості» (computed properties) у контексті React?
[⬆ Повернутися до списку](#список-запитань)

У контексті React «обчислювані властивості» зазвичай відносяться до техніки, яка дозволяє обчислювати значення властивостей компонента на основі інших значень або станів, використовуючи функції або обчислення. Це може бути корисно, коли вам потрібно проводити складні обчислення або маніпуляції з даними перед тим, як передати їх у компонент для відображення.

Обчислювані властивості можна використовувати для:

1. **Перетворення даних: **Наприклад, ви можете використовувати обчислювані властивості, щоб перетворити дані, отримані з контексту, перед тим як відобразити їх у компоненті.

2. **Фільтрації даних:** Якщо у вас є масив даних у контексті, ви можете використовувати обчислювані властивості, щоб фільтрувати цей масив на основі певних умов, перш ніж передавати його компоненту.

3. **Агрегації даних:** Ви можете агрегувати дані з контексту, наприклад, підсумовуючи числові значення або об'єднуючи рядки, перед тим як відобразити їх у компоненті.

4. **Генерації динамічних посилань або URL:** Якщо у вас є дані, які потрібно використовувати для генерації динамічних посилань або URL, ви можете використовувати обчислювані властивості для створення потрібних значень.

Приклад обчислюваної властивості:

```
import React, { createContext, useContext } from 'react';

const UserContext = createContext();

function UserProfile() {
  const user = useContext(UserContext);

  // Обчислювана властивість для генерації повного імені користувача
  const fullName = `${user.firstName} ${user.lastName}`;

  return (
    <div>
      <h1>Профіль користувача</h1>
      <p>Ім'я: {fullName}</p>
      <p>Вік: {user.age}</p>
    </div>
  );
}

function App() {
  const user = {
    firstName: 'Микола',
    lastName: 'Чудовий',
    age: 33,
  };

  return (
    <UserContext.Provider value={user}>
      <UserProfile />
    </UserContext.Provider>
  );
}

export default App;
```

У цьому прикладі `fullName` - це обчислювальна властивість, яка формує повне ім'я користувача на основі даних з контексту. Це допомагає спростити компонент `UserProfile`, не вимагаючи передачі додаткових властивостей через пропси.

## Як реалізувати «ледаче завантаження» (lazy loading) зображень у React?
[⬆ Повернутися до списку](#список-запитань)

Для реалізації «ледачого завантаження» зображень у React ви можете скористатися атрибутом `loading` у елемента `img` або бібліотеками, як-от `react-lazyload` або вбудованим механізмом `React.lazy` у поєднанні з `Suspense`.

#### Використання атрибута loading:

HTML5 вводить атрибут `loading` для елемента `img`, який може приймати значення «lazy». Це вказує браузеру завантажувати зображення тільки при наближенні до нього на екрані.

Приклад:

```
<img src="your-image-src.jpg" alt="Image" loading="lazy" />
```

#### Використання бібліотеки react-lazyload:

Бібліотека `react-lazyload` надає компонент `LazyLoad`, який можна обернути навколо зображення або будь-якого іншого контенту, який ви хочете відкласти в завантаженні.

Встановлення:

```
npm install react-lazyload
```

Приклад:

```
import LazyLoad from 'react-lazyload';

// ...

<LazyLoad height={240} offset={100}>
  <img src="your-image-src.jpg" alt="Image" />
</LazyLoad>
```

#### Використання React.lazy і Suspense:

Ви також можете використовувати `React.lazy` для ледачого завантаження компонентів, включаючи зображення, за допомогою динамічного імпорту. Це вимагає використання компонента `Suspense` для обробки очікування завантаження.

Приклад:

```
import React, { Suspense } from 'react';

const LazyImage = React.lazy(() => import('./LazyImage'));

function App() {
  return (
    <div>
      {/* Усередині компонента Suspense вказуємо компонент, який ми чекаємо */}
      <Suspense fallback={<div>Loading...</div>}>
        <LazyImage src="your-image-src.jpg" alt="Image" />
      </Suspense>
    </div>
  );
}

export default App;
```

У цьому прикладі компонент `LazyImage` повинен використовувати `React.lazy` для динамічного завантаження зображення.

## Що таке «рендер-пропси» (render props) і як вони використовуються?
[⬆ Повернутися до списку](#список-запитань)

«Рендер-пропси» (render props) - це патерн у React, який дає змогу передавати компоненту функцію через пропси, яку потім використовують для визначення, що компонент має відмалювати. Це дає змогу створювати компоненти з гнучкішою і багаторазово використовуваною логікою.

Принцип роботи рендер-пропсів:

1. Ви створюєте компонент, який приймає функцію як пропса.
2. Усередині цього компонента ви викликаєте передану функцію, передаючи їй необхідні дані або стан.
3. Функція, передана через пропси, вирішує, що саме рендерувати і повертає JSX для відображення.

Приклад використання рендер-пропсів:

```
import React from 'react';

class MouseTracker extends React.Component {
  constructor(props) {
    super(props);
    this.state = { x: 0, y: 0 };
  }

  handleMouseMove = (event) => {
    this.setState({ x: event.clientX, y: event.clientY });
  };

  render() {
    return (
      <div onMouseMove={this.handleMouseMove}>
        {/* Рендер-пропс використовується тут */}
        {this.props.render(this.state)}
      </div>
    );
  }
}

// Використання компонента з рендер-пропсом
const App = () => (
  <div>
    <h1>Mouse Position Tracker</h1>
    <MouseTracker render={mouse => (
      <p>Mouse position: {mouse.x}, {mouse.y}</p>
    )} />
  </div>
);

export default App;
```

У цьому прикладі `MouseTracker` приймає функцію через пропс `render`, яка визначає, що саме має бути намальовано всередині компонента `MouseTracker`.

Патерн рендер-пропсів забезпечує більшу гнучкість, оскільки дозволяє перевикористовувати логіку компонента для різних сценаріїв. Він часто використовується для створення бібліотечних компонентів, які надають різні можливості, але залишають гнучкість у руках користувачів компонентів.

## Як працює «ледаче завантаження» (lazy loading) сторонніх бібліотек у React?
[⬆ Повернутися до списку](#список-запитань)

«Ледаче завантаження» сторонніх бібліотек у React використовує динамічний імпорт для відкладеного завантаження коду бібліотеки тільки тоді, коли він дійсно потрібен. Це допомагає зменшити початковий обсяг завантажуваного JavaScript, покращуючи продуктивність застосунку, особливо на повільних або обмежених мережах.

Процес «ледачого завантаження» сторонніх бібліотек виглядає так:

#### 1) Динамічний імпорт:

Замість стандартного імпорту бібліотеки на початку файлу, ви використовуєте динамічний імпорт, який загортає імпорт у функцію, яка викликається лише за потреби. Це створює код-роздільник, який буде завантажений асинхронно під час виконання.

Приклад:

```
const MyComponent = () => {
  const handleClick = async () => {
    // Динамічний імпорт бібліотеки
    const library = await import('my-library');
    // Тепер ви можете використовувати бібліотеку
    library.doSomething();
  };

  return <button onClick={handleClick}>Завантаження бібліотеки</button>;
};
```

#### 2) React.lazy() і Suspense:

Якщо ви хочете ліниво завантажити компонент React зі сторонньої бібліотеки, ви можете використовувати `React.lazy()` разом із компонентом `Suspense`.

`React.lazy()` приймає функцію, яка повертає динамічний імпорт компонента. `Suspense` використовується для очікування завантаження ледачого компонента.

Приклад:

```
import React, { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => import('./LazyComponent'));

const App = () => (
  <div>
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  </div>
);

export default App;
```

#### 3) Webpack або інший інструмент збірки:

Під час збірки проєкту інструменти на кшталт Webpack аналізуватимуть код і виявлятимуть динамічні імпорти. Вони створять окремі файли для цих частин коду, які будуть завантажуватися в міру необхідності.

#### 4) Кешування:

Один раз завантажений код бібліотеки може кешуватися, щоб уникнути повторного завантаження під час наступних запитів.

З використанням «ледачого завантаження» сторонніх бібліотек ви зможете поліпшити початкове завантаження вашого застосунку, прискорити його роботу і зменшити навантаження на мережу, завантажуючи тільки той код, який дійсно необхідний.

## Що таке «реактивне програмування» (reactive programming) у контексті React?
[⬆ Повернутися до списку](#список-запитань)

«Реактивне програмування» (reactive programming) - це програмування, спрямоване на обробку потоків даних і подій за допомогою асинхронних і функціональних конструкцій. У контексті React, реактивне програмування передбачає створення компонентів, які реагують на зміни даних і автоматично оновлюють інтерфейс користувача без явної участі розробника.

У React реактивне програмування зазвичай пов'язане з концепцією «односпрямованого потоку даних» (unidirectional data flow) і «компонентів зі станом» (stateful components). Основними інструментами, які роблять реактивне програмування можливим у React, є стан компонентів і механізм рендерінгу.

Коли стан компонента змінюється (наприклад, унаслідок користувацької взаємодії або асинхронних операцій), React автоматично оновлює візуальне представлення цього компонента, а також усіх дочірніх компонентів, які залежать від змінених даних. Це дає змогу розробникам створювати декларативні інтерфейси, описуючи, який вигляд має мати інтерфейс залежно від стану, і дає змогу React піклуватися про те, як оновлювати подання в разі зміни стану.

Redux, MobX та інші бібліотеки управління станом також вносять концепції реактивного програмування в React, надаючи більш складні інструменти для управління даними і станом програми.

#### Основні поняття реактивного програмування в контексті React:

1. Стан (State): Дані, які можуть змінюватися в процесі виконання програми.

2. Ререндерінг (Re-rendering): Процес оновлення візуального представлення компонента на основі змін його стану або пропсів.

3. Пропси (Props): Дані, що передаються з батьківського компонента в дочірній компонент.

4. Односпрямований потік даних (Unidirectional Data Flow): Концепція, за якої дані поширюються від верхніх компонентів до нижніх, а зміни відбуваються через оновлення стану.

5. Зміна стану (State Mutation): Процес зміни даних, що зберігаються в стані компонента. Важливо робити зміни незмінними, щоб React міг правильно визначати, коли потрібно оновлювати компоненти.

Реактивне програмування допомагає керувати складними інтерфейсами і даними, що динамічно змінюються, забезпечуючи декларативність і ефективність у розробці інтерфейсів на основі React.

## Як обробляти помилки під час використання хуків (hooks) у React?
[⬆ Повернутися до списку](#список-запитань)

Обробка помилок під час використання хуків у React передбачає різні підходи залежно від ситуації. Ось кілька способів, як можна обробляти помилки під час роботи з хуками:

#### 1) Використання try/catch всередині компонента:

Усередині функціонального компонента можна використовувати блок try/catch для лову помилок, що виникають усередині хука.

```
import React, { useState } from 'react';

function MyComponent() {
  try {
    const [value, setValue] = useState('');

    // ...

  } catch (error) {
    // Обробка помилок
    console.error('Error:', error);
  }

  return (
    // ...
  );
}
```

#### 2) Використання componentDidCatch:

Якщо компонент містить інші компоненти з помилками (наприклад, хуки, які викликаються всередині дочірніх компонентів), ви можете використовувати метод життєвого циклу `componentDidCatch` для опрацювання помилок.

```
import React, { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  componentDidCatch(error, info) {
    this.setState({ hasError: true });
    console.error('Error:', error);
  }

  render() {
    if (this.state.hasError) {
      return <p>Something went wrong.</p>;
    }
    return this.props.children;
  }
}

export default ErrorBoundary;
```

Використовуйте цей компонент-обгортку для ваших компонентів, де можливі помилки.

#### 3) Custom Hook для обробки помилок:

Ви можете створити власний хук для обробки помилок і використовувати його у ваших компонентах.

```
import { useState } from 'react';

function useErrorHandler() {
  const [error, setError] = useState(null);

  const handleError = (error) => {
    setError(error);
    console.error('Error:', error);
  };

  const clearError = () => {
    setError(null);
  };

  return [error, handleError, clearError];
}

export default useErrorHandler;
```

#### 4) Бібліотеки для обробки помилок:

Існують такі бібліотеки, як `react-error-boundary`, які надають компоненти для зручнішого оброблення помилок і виведення інформації про помилки в інтерфейсі.

Обробка помилок під час використання хуків у React може залежати від конкретної ситуації та архітектури вашого застосунку. Важливо мати механізми для виявлення і відображення помилок, щоб зробити користувацький досвід більш інформативним і зрозумілим.

## Що таке «інкапсуляція стану» (state encapsulation) у React?
[⬆ Повернутися до списку](#список-запитань)

Інкапсуляція стану в React означає, що стан компонента, як-от дані, що можуть змінюватися в процесі виконання, підтримується та керується тільки всередині компонента і не доступний безпосередньо ззовні. Це дає змогу створювати компоненти з чітко визначеними інтерфейсами, через які взаємодія зі станом здійснюється шляхом виклику методів або звернення до певних властивостей.

Інкапсуляція стану в React досягається шляхом використання внутрішнього стану компонента за допомогою `useState` або `this.state` (у класових компонентах). Компонент самостійно керує змінами свого стану і може вирішувати, коли і як оновлювати DOM на основі цього стану.

Цей підхід сприяє модульності та покращує керованість коду. Компоненти можуть бути легко перевикористані, оскільки їхній внутрішній стан не впливає на інші компоненти. Зовнішні компоненти можуть взаємодіяти з внутрішнім станом через передачу props або виклики функцій-колбеків, які компонент надає.

## Як реалізувати анімований перехід між компонентами в React Native?
[⬆ Повернутися до списку](#список-запитань)

Для реалізації анімованих переходів між компонентами в React Native ви можете використовувати бібліотеки навігації або анімації. Ось приклади двох популярних способів:

#### React Navigation з анімаціями:

React Navigation - це популярна бібліотека для навігації в React Native, яка також підтримує анімовані переходи між екранами. Ви можете використовувати різні типи анімацій, такі як стандартні переходи, карусельні анімації тощо. Ось як це може виглядати:

```
import { createAppContainer, createStackNavigator } from 'react-navigation';

const StackNavigator = createStackNavigator({
  Screen1: { screen: Screen1Component },
  Screen2: { screen: Screen2Component },
}, {
  transitionConfig: () => ({
    screenInterpolator: (sceneProps) => {
      // Тут ви можете визначити свою кастомну анімацію
      // на основі sceneProps (інформація про поточний і попередній екрани)
    },
  }),
});

const AppContainer = createAppContainer(StackNavigator);
export default AppContainer;
```

#### React Native Navigation з анімаціями:

React Native Navigation - це інша популярна бібліотека для навігації в React Native. Вона також надає можливість налаштовувати анімації при переходах між екранами. Приклад:

```
import { Navigation } from 'react-native-navigation';

Navigation.setRoot({
  root: {
    stack: {
      children: [
        {
          component: {
            name: 'Screen1',
          },
        },
      ],
    },
  },
});

// В іншому місці, де ви налаштовуєте екрани
Navigation.registerComponent('Screen1', () => Screen1Component);
Navigation.registerComponent('Screen2', () => Screen2Component);
```

Обидва ці способи надають безліч можливостей для налаштування анімацій. Ви можете задавати свої власні анімації, використовуючи CSS-подібні властивості, або навіть під'єднувати бібліотеки для складніших анімацій. Важливо ознайомитися з документацією кожної бібліотеки, щоб зрозуміти, як реалізувати конкретні анімації, які ви хочете використовувати.

## Що таке «стабільні ідентифікатори» (stable keys) і навіщо вони потрібні в React?
[⬆ Повернутися до списку](#список-запитань)

Стабільні ідентифікатори, також відомі як «стабільні ключі» або «ключі з постійним значенням» (stable keys), у контексті React відносяться до значень, які використовуються як ключі під час рендерингу списків компонентів. Ці ключі повинні залишатися постійними для кожного елемента списку під час змін у даних, які впливають на рендеринг.

У React, коли ви візуалізуєте список компонентів з використанням `map()` або інших методів, кожному елементу в списку потрібно присвоїти унікальний ключ. Ключі допомагають React визначити, які елементи були додані, видалені або змінені в списку. Це дає змогу React ефективно оновлювати тільки ті частини DOM, які змінилися, замість повного перемальовування всього списку.

Значення ключів мають бути стабільними та унікальними для кожного елемента списку. Один із поширених підходів - використання унікальних ідентифікаторів із даних елементів як ключів. Наприклад:

```
function ItemList({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

Тут `item.id` слугує стабільним ідентифікатором (ключем) для кожного елемента списку. Якщо дані в `items` зміняться, React зможе ефективно оновити тільки відповідні елементи.

Використання стабільних ключів важливе для оптимізації продуктивності, оскільки неправильне або змінне використання ключів може призвести до непотрібного перемальовування компонентів і погіршення продуктивності під час оновлення списків.

## Як оновити стан компонента після зміни props?
[⬆ Повернутися до списку](#список-запитань)

У React існує кілька способів оновлення стану компонента після зміни його props. Це може знадобитися, коли компонент залежить від вхідних props і має реагувати на їхні зміни. Ось кілька підходів:

####1) componentDidUpdate(prevProps):

Метод `componentDidUpdate()` викликається після оновлення компонента. Ви можете порівняти попередні та поточні props за допомогою параметра `prevProps` та `this.props`, і за необхідності оновити стан:

```
componentDidUpdate(prevProps) {
  if (this.props.someProp !== prevProps.someProp) {
    this.setState({ someState: newValue });
  }
}
```

#### 2) getDerivedStateFromProps(nextProps, prevState):

Цей статичний метод викликається перед візуалізацією та щоразу, коли відбувається оновлення props. Ви можете повернути новий стан на основі нових props:

```
static getDerivedStateFromProps(nextProps, prevState) {
  if (nextProps.someProp !== prevState.prevPropValue) {
    return { someState: newValue };
  }
  return null;
}
```

#### 3) useState з useEffect:

Якщо ви використовуєте функціональні компоненти, ви можете використовувати `useState` для зберігання стану та `useEffect` для реагування на зміни props:

```
import React, { useState, useEffect } from 'react';

function MyComponent(props) {
  const [state, setState] = useState(initialState);

  useEffect(() => {
    if (props.someProp !== state.someState) {
      setState({ someState: newValue });
    }
  }, [props.someProp]);

  //...
}
```

Вибір підходу залежить від версії React і архітектури компонента.

Наприклад, починаючи з React 16.3 рекомендується використовувати `getDerivedStateFromProps` для таких сценаріїв, але для функціональних компонентів з React Hooks, `useState` та `useEffect` можуть бути зручнішими.

## Що таке «компоненти вищого порядку» (Higher-Order Components, HOC) у React?
[⬆ Повернутися до списку](#список-запитань)

Компоненти вищого порядку (Higher-Order Components, HOC) - це популярний патерн у React, який використовується для повторного використання логіки компонентів. HOC - це функції, які приймають компонент і повертають новий компонент із додатковою функціональністю.

Основна ідея HOC полягає в тому, щоб винести загальну логіку з компонентів і перенести її в окремі функції, які можна повторно використовувати на різних компонентах. Це допомагає поліпшити читабельність коду, зменшити дублювання коду і зробити компоненти більш специфічними для своєї ролі.

Приклад HOC може виглядати так:

```
// Приклад HOC, який додає обгортку навколо компонента і логіку обробки кліка
function withClickHandling(WrappedComponent) {
  return class WithClickHandling extends React.Component {
    handleClick = () => {
      // Загальна логіка обробки кліка
    };

    render() {
      return <WrappedComponent onClick={this.handleClick} {...this.props} />;
    }
  };
}

// Використання HOC для обертання компонента
const ButtonWithClickHandling = withClickHandling(Button);
```

У цьому прикладі `withClickHandling` - це HOC, який приймає компонент `Button` та повертає новий компонент `ButtonWithClickHandling`, обгорнутий логікою обробки кліка. Тепер `ButtonWithClickHandling` матиме додаткову властивість `onClick`, додану з HOC.

Ключова ідея полягає в тому, що ви можете створювати безліч таких HOC для різної загальної логіки і багаторазово застосовувати їх до різних компонентів. Це покращує модульність, перевикористовуваність і забезпечує чистішу архітектуру програми.

## Які є патерни для роботи з асинхронністю в React?
[⬆ Повернутися до списку](#список-запитань)

Роботу з асинхронністю в React можна вирішити за допомогою різних патернів. Деякі з них включають:

1. **Callback-функції:** Компонент передає callback-функції в дочірні компоненти, які викликаються після завершення асинхронної операції. Однак це може призвести до проблем, таких як «колбек-ад» (callback hell), коли вкладеність стає занадто глибокою.

2. **Проміси (Promises):** Використання промісів дає змогу більш структуровано організувати асинхронний код і уникнути колбек-аду. Можна використовувати .then() для обробки успішного виконання і .catch() для обробки помилок.

3. **Async/await:** Цей синтаксичний цукор дає змогу писати асинхронний код так, ніби це синхронний. З функцією, оголошеною як async, можна використовувати оператор await, щоб очікувати завершення промісу.

4. **Redux Thunk:** Для управління асинхронними операціями в Redux можна використовувати middleware Redux Thunk. Він дозволяє диспетчеру Redux обробляти функції замість дій, що спрощує виконання асинхронних завдань.

5. **React-Query:** Це бібліотека, яка полегшує управління станом і асинхронними запитами в додатку React. Вона надає хуки та компоненти для роботи з даними, кешування та інвалідації.

6. **RxJS:** Для складніших сценаріїв роботи з асинхронністю можна використовувати бібліотеку RxJS. Вона реалізує реактивне програмування і дає змогу створювати потоки даних, які можна обробляти і комбінувати.

💡 Пам'ятайте, що вибір патерну залежить від конкретних вимог вашого проєкту та рівня складності асинхронної логіки.

## Що таке «реактивний потік даних» (reactive data flow) у контексті React?
[⬆ Повернутися до списку](#список-запитань)

«Реактивний потік даних» - це концепція з реактивного програмування, яка стала популярною в контексті бібліотеки RxJS та інших реактивних бібліотек. У контексті React це стосується способу організації та управління даними та їхніми змінами в застосунку.

Основна ідея реактивного потоку даних полягає в тому, що компоненти реагують на зміни даних автоматично, без необхідності явно вказувати, яким чином оновлювати інтерфейс під час зміни даних. Замість того щоб імперативно оновлювати UI під час зміни стану, реактивна система автоматично оновлює UI під час зміни даних.

#### Патерни для реалізації «реактивного потоку даних»:

1. **React-Redux:** За допомогою бібліотеки Redux, стан програми зберігається в єдиному сховищі, і компоненти підписуються на зміни цього стану. Коли стан змінюється, компоненти автоматично оновлюються.

2. **Hooks та Context API:** Із введенням хуків (наприклад, useState і useEffect) і Context API в React, компоненти можуть реагувати на зміни стану і контексту без явної підписки на них.

3. **React Query:** Бібліотека React Query надає реактивні хуки для роботи з даними, автоматично керуючи кешуванням і оновленнями даних.

4. **RxJS та observables**: RxJS дає змогу створювати та маніпулювати потоками даних за допомогою observables. Це можна використовувати для більш складних сценаріїв управління реактивним потоком даних.

Загалом, реактивний потік даних у контексті React прагне спростити й автоматизувати оновлення призначеного для користувача інтерфейсу у відповідь на зміни даних, що сприяє передбачуванішому й ефективнішому управлінню станом застосунку.
