## Що таке React?

**React** - це бібліотека JavaScript, розроблена компанією Facebook, яка використовується для створення користувацьких інтерфейсів.

Вона дає змогу розбивати призначений для користувача інтерфейс на невеликі компоненти, які можуть оновлюватися незалежно один від одного, що забезпечує ефективне управління станом і оновленнями на веб-сторінці.

React використовує віртуальне DOM (Document Object Model) для оптимізації продуктивності, даючи змогу ефективно оновлювати тільки частини інтерфейсу, що змінилися.

Однією з головних концепцій React є "односпрямований потік даних", що полегшує відстеження змін і управління станом програми. React широко використовується в розробці веб-додатків і мобільних додатків з використанням фреймворка React Native.

## Які основні переваги використання React?

Використання React має кілька ключових переваг:

1. Віртуальний DOM: React використовує віртуальний DOM для ефективного управління оновленнями інтерфейсу. Це дає змогу мінімізувати операції безпосередньо з реальним DOM, що підвищує продуктивність програми.

2. Компонентний підхід: React дає змогу розбивати користувацький інтерфейс на безліч дрібних компонентів. Ці компоненти можуть бути повторно використані, що спрощує розробку, тестування та обслуговування коду.

3. Односпрямований потік даних: React забезпечує односпрямований потік даних, що спрощує відстеження змін стану і робить код більш передбачуваним і легко підтримуваним.

4. Оголошувальний підхід: React використовує оголошувальний стиль програмування, який дає змогу описувати, який вигляд має мати інтерфейс залежно від стану. Це робить код більш читабельним і зрозумілим.

5. Екосистема і співтовариство: React має велику й активну спільноту розробників, що забезпечує безліч готових рішень, бібліотек та інструментів для розробки.

6. React Native: Для розробки мобільних додатків можна використовувати React Native, який дає змогу використовувати React для створення нативних мобільних додатків під різні платформи.

7. Висока продуктивність: Завдяки віртуальному DOM і оптимізаціям, React здатний забезпечувати хорошу продуктивність навіть під час роботи з великими і складними інтерфейсами.

## Що таке JSX?

**JSX** (JavaScript XML) - це розширення синтаксису JavaScript, що використовується в React для опису структури користувацького інтерфейсу.

Цей синтаксис дає змогу об'єднувати код JavaScript і HTML-подібні елементи в одному місці, що робить створення компонентів React більш інтуїтивним і читабельним.

JSX дає змогу вставляти JavaScript-вирази всередині тегів, укладаючи їх у фігурні дужки. Наприклад:

```
const name = "Микола";
const element = <h1>Привіт, {name}</h1>;
```

У цьому прикладі змінна name вставлена всередині JSX-елемента за допомогою фігурних дужок.

JSX також дає змогу описувати користувацькі компоненти користувача у вигляді елементів, що робить код більш структурованим і зручним для читання:

```
function Greeting(props) {
  return <p>Привіт, {props.name}!</p>;
}
```

JSX-код потрібно перетворити на звичайний JavaScript-код перед тим, як він буде виконаний у браузері. Для цього використовуються інструменти компіляції, зазвичай включені в складальний процес проекту на React.

## Які основні відмінності між компонентами класів і функціональними компонентами в React?

У React існують два основні способи створення компонентів: з використанням класів і з використанням функціональних компонентів. Ось основні відмінності між ними:

### Компоненти класів:

1. Синтаксис: Компоненти класів визначаються як класи, що розширюють базовий клас React.Component.

2. Стан (state): Компоненти класів мають вбудовану підтримку для стану (state), що дає їм змогу зберігати та керувати даними всередині компонента.

3. Методи життєвого циклу: Компоненти класів мають широкий набір методів життєвого циклу (наприклад, componentDidMount, componentDidUpdate, componentWillUnmount), які дають змогу реагувати на різні етапи життя компонента.

4. Пропси (props): Пропси передаються в компоненти класів через атрибути під час використання. Вони доступні через this.props всередині методів компонента.

### Функціональні компоненти:

1. Синтаксис: Функціональні компоненти визначаються як звичайні функції.

2. Стан (state): Спочатку функціональні компоненти не підтримували стан. Однак із появою хуків (hooks) у React (починаючи з React 16.8) функціональні компоненти тепер можуть використовувати стан та інші можливості, що раніше були доступні тільки компонентам класів.

3. Хуки (hooks): Функціональні компоненти можуть використовувати хуки, як-от useState, useEffect та інші, для керування станом, ефектами та іншими аспектами.

4. Пропси (props): Пропси також передаються функціональним компонентам, але доступні вони як аргументи функції.

Загалом, з появою хуків, функціональні компоненти стали кращим вибором для більшості випадків у React, оскільки вони забезпечують простіший синтаксис, який можна прочитати, а також спрощений спосіб керування станом і ефектами.

## Що таке Virtual DOM, та як він працює?

Virtual DOM (віртуальне DOM) - це концепція, яку використовують у бібліотеках і фреймворках, як-от React, для оптимізації оновлень реального DOM (Document Object Model) і підвищення продуктивності веб-додатків.

Реальний DOM - це представлення структури веб-сторінки в браузері у вигляді дерева об'єктів. Коли стан програми змінюється і потрібне оновлення інтерфейсу, браузер виконує зміни безпосередньо в реальному DOM. Однак багаторазові та часті оновлення реального DOM можуть бути витратними з погляду продуктивності, особливо для великих і складних інтерфейсів.

Віртуальний DOM розв'язує цю проблему таким чином:

1. Створення віртуального DOM: Під час зміни стану застосунку React створює віртуальне представлення DOM-структури, яка є легковажною копією реального DOM.

2. Порівняння віртуального DOM: React порівнює попередній стан віртуального DOM із новим станом, виявляючи, які частини інтерфейсу було змінено.

3. Генерація різниці (патч): На основі порівняння React створює мінімальний набір змін, необхідних для оновлення віртуального DOM згідно з новим станом.

4. Застосування змін: Створені зміни застосовуються до реального DOM тільки одним оновленням, що дає змогу уникнути множинних маніпуляцій із реальним DOM.

Використання віртуального DOM дає змогу значно поліпшити продуктивність, оскільки оновлення реального DOM відбуваються тільки в необхідних місцях. Це також робить розробку більш зручною і передбачуваною, оскільки розробнику не потрібно вручну керувати безліччю змін на реальному DOM.

## Які методи життєвого циклу компонентів ви знаєте?

У React компоненти проходять через низку етапів свого "життєвого циклу", включно з такими методами:

1. **constructor(props)**: Викликається під час створення компонента. Тут відбувається ініціалізація стану і прив'язка методів.

2. **componentDidMount()**: Викликається після того, як компонент було вставлено в DOM. Часто використовується для завантаження даних із сервера.

3. **componentDidUpdate(prevProps, prevState)**: Викликається після оновлення компонента. Дозволяє реагувати на зміни пропсів або стану.

4. **shouldComponentUpdate(nextProps, nextState)**: Дозволяє оптимізувати оновлення компонента, повертаючи false, якщо оновлення не потрібне.

5. **componentWillUnmount()**: Викликається перед видаленням компонента з DOM. Використовується для очищення ресурсів.

6. **static getDerivedStateFromProps(props, state)**: Рідко використовується. Дозволяє оновити стан на основі нових пропсів.

7. **getSnapshotBeforeUpdate(prevProps, prevState)**: Рідко використовується. Дозволяє отримати інформацію з DOM перед його оновленням.

8. **componentDidCatch(error, info)**: Використовується для обробки помилок у дочірніх компонентах.

Це лише короткий огляд методів життєвого циклу компонентів у React.

## Що таке "стан" (state) компонента в React?

"Стан" (state) у React є об'єктом, який містить дані, що впливають на те, як компонент відображається і поводиться. Стан є одним із фундаментальних понять React і використовується для зберігання інформації, яка може змінюватися під час роботи програми.

Коли стан компонента змінюється, React автоматично перерендерує компонент, щоб відобразити новий стан. Стан зазвичай ініціалізується в методі constructor() компонента, і для його оновлення використовується метод setState().

Приклад:

```
import React, { Component } from "react";

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0, // Початковий стан
    };
  }

  increment = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <p>Счетчик: {this.state.count}</p>
        <button onClick={this.increment}>Збільшити</button>
      </div>
    );
  }
}

export default Counter;
```

У цьому прикладі компонент Counter має стан count, який оновлюється при кліці на кнопку. Під час виклику setState(), React оновить стан і перерендерить компонент, відображаючи нове значення count.

## Як оновити стан компонента?

У React для оновлення стану компонента слід використовувати метод setState(). Цей метод приймає або об'єкт з оновленнями стану, або функцію, яка повертає об'єкт з оновленнями. Під час виклику setState(), React оновить стан компонента і перерендерує його, щоб відобразити новий стан.

Приклад використання setState():

```
import React, { Component } from "react";

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
    };
  }

  increment = () => {
    //  Оновлення стану з використанням об'єкта
    this.setState({ count: this.state.count + 1 });
  };

  decrement = () => {
    // Оновлення стану з використанням функції
    this.setState((prevState) => {
      return { count: prevState.count - 1 };
    });
  };

  render() {
    return (
      <div>
        <p>Счетчик: {this.state.count}</p>
        <button onClick={this.increment}>Збільшити</button>
        <button onClick={this.decrement}>Зменшити</button>
      </div>
    );
  }
}

export default Counter;
```

У цьому прикладі increment() і decrement() оновлюють стан count за допомогою setState(). Важливо використовувати функції під час оновлення стану, особливо якщо новий стан залежить від попереднього стану, щоб уникнути проблем з асинхронністю.

## Что такое пропсы (props) в React?

"Пропси" (props) у React - це механізм передачі даних від батьківського компонента до дочірнього. Вони являють собою атрибути, які задаються при створенні компонента і не можуть бути змінені самим компонентом, який їх отримує. Пропси використовуються для передачі інформації про стан або конфігурацію компонента.

Приклад використання пропсів:

```
import React from "react";

function Welcome(props) {
  return <h1>Вітаю, {props.name}!</h1>;
}

const App = () => {
  return <Welcome name="Ірина" />;
};

export default App;
```

У цьому прикладі компонент **Welcome** приймає пропс **name** і використовує його для виведення персоналізованого привітання. Компонент **App** передає значення "Ірина" в пропс **name** компонента **Welcome**.

Пропси передаються у вигляді об'єкта і доступні як властивості (**props**) всередині дочірнього компонента.

Використання пропсів дає змогу створювати більш гнучкі та перевикористовувані компоненти, адже можна налаштовувати їхню поведінку та відображення ззовні.

## У чому різниця між станом і пропсами в React?

Стан (**state**) і пропси (**props**) - це два основні концепти в React, які використовуються для управління даними в компонентах. Вони мають різні цілі та характеристики:

#### Стан (state):

1. Стан - це внутрішні дані компонента, які можуть змінюватися під час виконання.
2. Визначається та керується самим компонентом, у якому він знаходиться.
3. Зміна стану викликає перерендеринг компонента, щоб відобразити новий стан.
4. Доступно тільки для компонента, у якому було визначено стан.
5. Оновлюється з використанням методу setState().

#### Пропсы (props):

1. Пропси - це дані, що передаються від батьківського компонента до дочірнього компонента.
2. Не можна змінити пропси всередині дочірнього компонента. Вони вважаються "тільки для читання".
3. Пропси слугують для налаштування та передавання даних у компоненти.
4. Використовуються для зв'язку між різними компонентами і передавання інформації вниз по ієрархії.
5. Не спричиняють перерендерінг у разі їхньої зміни.

Коротко кажучи, стан призначений для зберігання і управління даними, що змінюються всередині компонента, тоді як пропси призначені для передачі даних від батьківського компонента до дочірнього. Обидва ці концепти допомагають створювати динамічні та перевикористовувані інтерфейси в React додатках.

## Як обробляти події в React?

У React обробка подій відбувається з використанням синтаксису, аналогічного обробці подій у нативному JavaScript, але з деякими відмінностями. Ось як обробляти події в React:

1. Створення методу обробки події: Створіть метод усередині компонента, який буде виконуватися при виникненні події. Назва методу зазвичай починається з префікса "handle", за яким слідує ім'я події або описове ім'я.

2. Прив'язка методу до елемента: Прив'яжіть створений метод до елемента, який генеруватиме подію. Це робиться за допомогою JSX, вказавши метод як значення атрибута події.

3. Використання аргументів: Усередині методу обробки події ви можете отримати доступ до об'єкта події та використовувати його властивості, такі як `target`, щоб отримати інформацію про подію.

Приклад обробки кліка:

```
import React, { Component } from "react";

class Button extends Component {
  handleClick = () => {
    console.log("Кнопка була натиснута");
  };

  render() {
    return <button onClick={this.handleClick}>Натисни на мене</button>;
  }
}

export default Button;
```

В этом примере метод `handleClick` вызывается при клике на кнопку, выводя сообщение в консоль.

Важно заметить, что при передаче метода обработки события в качестве атрибута JSX, не следует вызывать его с помощью круглых скобок (например, не пишите `onClick={this.handleClick()}`), так как это вызовет выполнение метода сразу при рендеринге.

## Що таке умовний рендеринг у React?

Умовний рендеринг у React - це підхід, за якого вирішується, чи повинен компонент або його частина відображатися на основі будь-якої умови. Це дає змогу динамічно контролювати, які елементи інтерфейсу будуть показані або приховані залежно від стану застосунку або інших чинників.

Приклад умовного рендерингу:

```
import React, { Component } from "react";

class Greeting extends Component {
  render() {
    const isLoggedIn = this.props.isLoggedIn;

    if (isLoggedIn) {
      return <h1>Вітаємо вас на нашому сайті!</h1>;
    } else {
      return <h1>Будь ласка, увійдіть до системи!</h1>;
    }
  }
}

export default Greeting;
```

У цьому прикладі компонент Greeting залежно від значення пропса isLoggedIn рендерить різні заголовки. Якщо isLoggedIn дорівнює true, відображається привітання, в іншому разі - запрошення до входу в систему.

Умовний рендеринг можна реалізувати також за допомогою тернарного оператора:

```
class Greeting extends Component {
  render() {
    const isLoggedIn = this.props.isLoggedIn;

    return (
      <div>
        {isLoggedIn ? (
          <h1>Привіт, Сергій!</h1>
        ) : (
          <h1>Будь ласка, авторизуйтеся на сайті.</h1>
        )}
      </div>
    );
  }
}
```

Умовний рендеринг особливо корисний, коли потрібно адаптувати інтерфейс на основі динамічних даних або станів, таких як авторизація користувача, наявність даних та інші умови.

## Як передати дані між компонентами вгору і вниз за ієрархією?

У React дані можуть передаватися між компонентами вгору і вниз по ієрархії з використанням пропсів (props) і колбеків (callback функцій). Ось як це працює:

#### Передача даних вниз за ієрархією (від батька до дочірнього компонента):

Пропси (props): Батьківський компонент передає дані своєму дочірньому компоненту через пропси. Дочірній компонент може отримати доступ до цих даних як властивості (props).

Приклад:

```
// Батьківський компонент
import React from "react";
import ChildComponent from "./ChildComponent";

const ParentComponent = () => {
  const data = "Дані для дочірнього компонента";

  return <ChildComponent dataProp={data} />;
};

// Дочірній компонент
import React from "react";

const ChildComponent = (props) => {
  return <p>{props.dataProp}</p>;
};

export default ChildComponent;
```

#### Передавання даних вгору за ієрархією (від дочірнього компонента до батька):

Колбеки (callback функції): Батьківський компонент передає функцію як пропса дочірньому компоненту. Дочірній компонент може викликати цю функцію, передаючи їй дані назад вгору по ієрархії.

Приклад:

```
// Батьківський компонент
import React, { useState } from "react";
import ChildComponent from "./ChildComponent";

const ParentComponent = () => {
  const [receivedData, setReceivedData] = useState("");

  const handleDataChange = (data) => {
    setReceivedData(data);
  };

  return (
    <div>
      <p>Отримані дані: {receivedData}</p>
      <ChildComponent onDataChange={handleDataChange} />
    </div>
  );
};

// Дочірній компонент
import React from "react";

const ChildComponent = (props) => {
  const sendDataToParent = () => {
    props.onDataChange("Дані від дочірнього компонента");
  };

  return <button onClick={sendDataToParent}>Надіслати дані</button>;
};

export default ChildComponent;
```

Це дає змогу дочірньому компоненту впливати на дані та стан батьківського компонента.

Використовуючи цей підхід, ви можете ефективно передавати й оновлювати дані між компонентами вгору і вниз по ієрархії.

## Как выполнить HTTP-запросы в React?

Для выполнения HTTP-запросов в React обычно используются библиотеки, такие как axios или встроенный fetch. Вот как выполнить GET-запрос с использованием библиотеки axios:

1. Установите библиотеку axios с помощью npm или yarn:

```
npm install axios
```

або

```
yarn add axios
```

2. У компоненті, де ви хочете виконати HTTP-запит:

```
import React, { useState, useEffect } from "react";
import axios from "axios";

const DataFetching = () => {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    axios
      .get("https://api.example.com/data")
      .then((response) => {
        setData(response.data);
        setIsLoading(false);
      })
      .catch((error) => {
        setError(error.message);
        setIsLoading(false);
      });
  }, []); // Порожній масив залежностей, щоб запит виконався тільки один раз

  if (isLoading) {
    return <p>Завантаження...</p>;
  }

  if (error) {
    return <p>Error: {error}</p>;
  }

  return (
    <div>
      <h2>Fetched Data</h2>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
};

export default DataFetching;
```

У цьому прикладі ми використовуємо хук useState для управління станом даних, завантаження і помилок. Хук useEffect використовується для виконання HTTP-запиту під час монтування компонента. Залежно від результату запиту, ми оновлюємо стан для відображення даних, завантаження або помилки.

## Що таке контекст (context) у React і для чого він використовується?

Контекст (context) у React - це механізм, який дає змогу передавати дані глибоко вниз по ієрархії компонентів, минаючи пропси (props). Він використовується, коли певні дані потрібні в безлічі компонентів, і передача через кожен компонент стає незручною.

Контекст дає змогу створити «контекстне» оточення, в якому компоненти можуть отримувати доступ до даних без необхідності явно передавати їх через пропси. Це особливо корисно для глобальних даних, таких як дані автентифікації, теми оформлення та інші загальні стани.

Для створення контексту використовуються два елементи: провайдер (Provider) і споживач (Consumer).

Приклад використання контексту:

```
import React, { createContext, useContext } from "react";

// Створюємо контекст
const UserContext = createContext();

// Компонент, який постачає дані
const UserProvider = ({ children }) => {
  const user = { name: "Serhii", role: "developer" };

  return <UserContext.Provider value={user}>{children}</UserContext.Provider>;
};

// Компонент, що використовує контекст
const UserInfo = () => {
  const user = useContext(UserContext);

  return (
    <div>
      <p>Name: {user.name}</p>
      <p>Role: {user.role}</p>
    </div>
  );
};

// Головний компонент, який обертає додаток у провайдер даних
const App = () => {
  return (
    <UserProvider>
      <UserInfo />
    </UserProvider>
  );
};

export default App;
```

У цьому прикладі контекст UserContext використовується для передачі інформації про користувача від UserProvider до UserInfo, минаючи пропси. Компонент UserInfo використовує хук useContext, щоб отримати доступ до даних контексту.

Контекст слід використовувати обережно і тільки там, де це справді необхідно, оскільки це може ускладнити розуміння взаємодії компонентів і ускладнити налагодження.

## Як реалізувати PureComponent?

Щоб створити **PureComponent** у React, ви можете використовувати класи або функціональні компоненти з хуками.

1. З використанням класів:

```
import React, { PureComponent } from "react";

class MyPureComponent extends PureComponent {
  render() {
    return <div>{/* Код компоненту */}</div>;
  }
}

export default MyPureComponent;
```

2. З використанням функціональних компонентів і хуків:

```
import React, { memo } from "react";

const MyPureComponent = () => {
  return <div>{/* Код компоненту */}</div>;
};

export default memo(MyPureComponent);
```

Обидва варіанти **PureComponent** автоматично порівнюють пропси і стан, і перемальовують компонент тільки в разі змін даних. Це може істотно поліпшити продуктивність, уникаючи непотрібних перемальовок.

## Що таке ключі (keys) у списках React-елементів і навіщо вони потрібні?

У React, ключі (keys) - це спеціальні атрибути, які використовуються під час рендерингу списків компонентів або елементів. Вони допомагають React оптимізувати процес оновлення та перемальовування компонентів у списках.

Ключі призначаються кожному елементу в списку і мають бути унікальними серед своїх сусідніх елементів. Коли React оновлює список компонентів, він використовує ключі для визначення, які елементи були додані, видалені або змінені. Без ключів React буде перемальовувати і оновлювати всі елементи в списку, що може призвести до погіршення продуктивності.

Приклад використання ключів:

```
import React from "react";

const TodoList = ({ data }) => {
  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
};

export default TodoList;
```

У цьому прикладі кожному елементу списку завдань (todo) присвоюється унікальний ключ (todo.id). Це дає змогу React ефективно оновлювати тільки змінені елементи, мінімізуючи кількість перемальовок.

Ключі особливо важливі під час роботи зі списками, які можуть змінюватися в часі, наприклад, під час додавання, видалення або переупорядкування елементів.

## Як використовувати стилі в React-компонентах?

У React для стилізації компонентів можна використовувати кілька підходів: вбудовані стилі (inline styles), стилі з використанням CSS-класів і бібліотеки стилів. Ось як це робиться:

#### 1. Вбудовані стилі (Inline Styles):

Вбудовані стилі являють собою об'єкт JavaScript, де ключі - це назви CSS-властивостей, а значення - відповідні значення властивостей.

```
import React from "react";

const MyComponent = () => {
  const styles = {
    backgroundColor: "blue",
    color: "yellow",
    padding: "12px",
    borderRadius: "20px",
  };

  return <div style={styles}>Стилізований компонент</div>;
};

export default MyComponent;
```

#### 2. Стилі з використанням CSS-класів:

Ви можете визначити CSS-класи в окремих файлах і додати їх до елементів у компонентах.

```
// styles.css
.myClass {
  background-color: blue;
  color: yellow;
  padding: 12px;
  border-radius: 20px;
}

// MyComponent.jsx
import React from 'react';
import './styles.css';

const MyComponent = () => {
  return <div className="myClass">Стилізований компонент</div>;
};

export default MyComponent;
```

#### 3. Бібліотеки стилів:

Існує безліч бібліотек для стилізації React-компонентів, таких як Styled Components, Emotion, CSS Modules та інші. Ці бібліотеки надають синтаксис для створення компонентів зі стилями всередині коду.

```
// Styled Components
import React from "react";
import styled from "styled-components";

const StyledDiv = styled.div`
  background-color: blue;
  color: yellow;
  padding: 12px;
  border-radius: 20px;
`;

const MyComponent = () => {
  return <StyledDiv>Стилізований компонент</StyledDiv>;
};

export default MyComponent;
```

Вибір методу залежить від уподобань та вимог проєкту. Важливо звернути увагу на підтримку класів, перевикористання стилів і простоту супроводу під час вибору підходу.

## Що таке «керовані компоненти» (controlled components)?

«Керовані компоненти» (controlled components) - це поняття, пов'язане з управлінням станом форм і введення даних у React. У керованих компонентах значення елемента введення (наприклад, текстового поля або чекбокса) контролюється станом React компонента, а не DOM елементом.

Коли компонент контролює значення введення, він зберігає це значення у своєму стані й оновлює його за допомогою обробників подій (наприклад, у разі зміни тексту в полі введення). Це дає змогу мати повний контроль над даними форми та легко реагувати на зміни.

Приклад керованого компонента з текстовим полем:

```
import React, { useState } from "react";

const ControlledComponent = () => {
  const [inputValue, setInputValue] = useState("");

  const handleInputChange = (event) => {
    setInputValue(event.target.value);
  };

  return (
    <div>
      <input type="text" value={inputValue} onChange={handleInputChange} />
      <p>Введене значення: {inputValue}</p>
    </div>
  );
};

export default ControlledComponent;
```

У цьому прикладі значення текстового поля inputValue пов'язане зі станом компонента. Коли значення текстового поля змінюється, викликається обробник handleInputChange, який оновлює стан і, отже, значення текстового поля.

Використання керованих компонентів забезпечує передбачуваність стану, спрощує взаємодію з даними і дає змогу виконувати валідацію та інші операції над введеними даними перед їхнім надсиланням на сервер.

## Що таке «некеровані компоненти» (uncontrolled components)?

«Некеровані компоненти» (uncontrolled components) - це поняття, протилежне керованим компонентам, і воно відноситься до управління станом форм і введення даних у React. У разі некерованих компонентів, значення елемента введення (наприклад, input або textarea) зберігається безпосередньо в DOM, і React компонент не керує цим значенням.

Замість використання стану компонента для зберігання значення елемента введення, некеровані компоненти звертаються до DOM безпосередньо для отримання та оновлення значення.

Приклад некерованого компонента з текстовим полем:

```
import React, { useRef } from "react";

const UncontrolledComponent = () => {
  const inputRef = useRef(null);

  const handleButtonClick = () => {
    alert("Значення в полі введення: " + inputRef.current.value);
  };

  return (
    <div>
      <input type="text" ref={inputRef} />
      <button onClick={handleButtonClick}>Показати значення</button>
    </div>
  );
};

export default UncontrolledComponent;
```

У цьому прикладі значення текстового поля не зберігається в стані компонента. Натомість ми використовуємо useRef для отримання посилання на DOM-елемент і потім отримуємо його значення через inputRef.current.value.

Некеровані компоненти можуть бути корисними, коли у вас є особливі випадки або вимоги, де контроль над станом через React не є оптимальним підходом. Однак, у більшості випадків, керовані компоненти забезпечують більш передбачуване і зручне управління даними у формах.

## Що таке «підйом стану» (lifting state up)?

«Підйом стану» (lifting state up) - це патерн у React, який передбачає переміщення стану з дочірніх компонентів до батьківських компонентів, щоб розділяти й керувати станом на вищому рівні та передавати його через пропси.

Цей підхід особливо корисний, коли кілька компонентів повинні мати доступ до одного й того самого стану або коли стан повинен бути синхронізований між різними частинами програми.

Приклад із підйомом стану:

```
import React, { useState } from "react";

const TemperatureInput = ({ scale, temperature, onTemperatureChange }) => {
  return (
    <fieldset>
      <legend>Введіть температуру в градусах {scale}:</legend>
      <input
        value={temperature}
        onChange={(e) => onTemperatureChange(e.target.value)}
      />
    </fieldset>
  );
};

const Calculator = () => {
  const [celsius, setCelsius] = useState("");
  const [fahrenheit, setFahrenheit] = useState("");

  const handleCelsiusChange = (value) => {
    setCelsius(value);
    setFahrenheit((value * 9) / 5 + 32);
  };

  const handleFahrenheitChange = (value) => {
    setFahrenheit(value);
    setCelsius(((value - 32) * 5) / 9);
  };

  return (
    <div>
      <TemperatureInput
        scale="C"
        temperature={celsius}
        onTemperatureChange={handleCelsiusChange}
      />
      <TemperatureInput
        scale="F"
        temperature={fahrenheit}
        onTemperatureChange={handleFahrenheitChange}
      />
    </div>
  );
};

export default Calculator;
```

У цьому прикладі компонент Calculator піднімає стан температур із TemperatureInput компонентів. При зміні температури в одному з вводів, стан піднімається в батьківський компонент Calculator, який потім оновлює стан для іншого вводу, забезпечуючи синхронізацію температур в обох шкалах.

«Підйом стану» допомагає спростити керування даними та їхню синхронізацію між компонентами, особливо під час роботи з компонентами на різних рівнях ієрархії.

## Як створити форму в React?

Створення форми в React охоплює використання HTML-елементів форми в JSX і управління введенням даних за допомогою стану. Ось як це робиться:

#### Створення компонента форми:

Спочатку створіть компонент форми і визначте елементи форми всередині нього, такі як текстові поля, чекбокси, кнопки тощо.

```
import React, { useState } from "react";

const MyForm = () => {
  const [formData, setFormData] = useState({
    name: "",
    email: "",
    // інші поля форми
  });

  const handleInputChange = (event) => {
    const { name, value } = event.target;
    setFormData({
      ...formData,
      [name]: value,
    });
  };

  const handleSubmit = (event) => {
    event.preventDefault();
    console.log(formData);
    // відправляємо дані на сервер або виконуємо інші операції
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
          Ім&apos;я:
        <input
          type="text"
          name="name"
          value={formData.name}
          onChange={handleInputChange}
        />
      </label>
      <br />
      <label>
        Email:
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleInputChange}
        />
      </label>
      <br />
      {/* Інші поля форми  */}
      <button type="submit">Отправить</button>
    </form>
  );
};

export default MyForm;
```

#### Управління станом:

У цьому прикладі використовується хук useState, щоб керувати станом даних форми. Обробник handleInputChange викликається при зміні полів введення і оновлює стан форми.

#### Обробка надсилання:

Обробник handleSubmit викликається під час надсилання форми. У цьому випадку ми запобігаємо стандартній поведінці надсилання форми на сервер за допомогою event.preventDefault(), щоб продемонструвати обробку даних на клієнті.

#### Прив'язка значень до полів:

Значення полів форми пов'язані зі станом форми. value елементів введення встановлюється рівним значенням зі стану, а при зміні полів викликається обробник handleInputChange.

#### Надсилання даних:

Після заповнення форми і натискання кнопки відправлення, дані можна використовувати для відправлення на сервер, виконання операцій або інших необхідних дій.

## Як реалізувати умовне додавання класу до елемента в React?

У React ви можете умовно додати клас до елемента, використовуючи тернарний оператор або функцію для визначення класового імені. Ось приклади обох підходів:

#### З використанням тернарного оператора:

```
import React from "react";

const MyComponent = ({ isActive }) => {
  return (
    <div className={isActive ? "active" : "inactive"}>
      Вміст компонента
    </div>
  );
};

export default MyComponent;
```

У цьому прикладі клас active буде додано до елемента, якщо isActive дорівнює true, інакше буде додано клас inactive.

#### З використанням функції для визначення класу:

```
import React from "react";

const MyComponent = ({ isActive }) => {
  const getClassNames = () => {
    return isActive ? "active" : "inactive";
  };

  return <div className={getClassNames()}>Вміст компонента</div>;
};

export default MyComponent;
```

Тут ми визначаємо функцію getClassNames, яка повертає клас залежно від значення isActive.

Якщо ви хочете додати кілька класів, ви можете використовувати об'єднання рядків або бібліотеки, такі як classnames.

```
import React from "react";
import classnames from "classnames";

const MyComponent = ({ isActive, isHighlighted }) => {
  const classNames = classnames({
    active: isActive,
    highlighted: isHighlighted,
  });

  return <div className={classNames}>Вміст компонента</div>;
};

export default MyComponent;
```

У цьому прикладі classnames бібліотека дає змогу додати кілька класів на основі об'єкта, де ключі - це назви класів, а значення - умови, за яких клас буде додано.

## Що таке фрагменти (fragments) у React?

Фрагменти (fragments) - це механізм у React, який дає змогу вам групувати дочірні елементи без необхідності створювати зайві DOM-елементи. Вони дають змогу повернути кілька елементів із компонента без обертання їх у додатковий DOM-контейнер.

До появи фрагментів, якщо ви хотіли повернути кілька елементів із компонента, вам доводилося обгортати їх у додатковий елемент (наприклад, <div>) або використовувати масив, що могло призвести до зайвого рівня вкладеності або проблем із CSS.

З використанням фрагментів, це має чистіший і ефективніший вигляд:

```
import React from "react";

const MyComponent = () => {
  return (
    <>
      <div>Блок 1</div>
	  <div>Блок 2</div>
    </>
  );
};

export default MyComponent;
```

Фрагменти можуть бути оголошені за допомогою порожніх <> і </>, а всередині них ви можете розміщувати будь-яку кількість дочірніх елементів.

Фрагменти особливо корисні, коли вам потрібно повернути кілька елементів з компонента, наприклад, з умовних блоків або маппінгу масивів, і ви хочете уникнути створення додаткових контейнерів у DOM.

## Яким чином можна оптимізувати продуктивність React-додатку?

Оптимізація продуктивності React-додатку - це важливий аспект, який може суттєво вплинути на користувацький досвід. Ось деякі способи оптимізації продуктивності:

1. Використовуйте керовані компоненти:

Використовуйте керовані компоненти для контролю над даними у формах і введенні. Це дасть змогу мінімізувати непотрібні перемальовування і полегшить обробку введених даних.

2. Використовуйте ключі (keys) правильно:

Під час рендерингу списків компонентів переконайтеся, що в кожного елемента є унікальний ключ. Це дасть змогу React ефективно оновлювати тільки змінені елементи.

3. Ледаче завантаження (Code Splitting):

Розділіть ваш застосунок на невеликі фрагменти і використовуйте механізм ледачого завантаження для завантаження компонентів тільки тоді, коли вони дійсно потрібні.

4. Мемоїзація:

Використовуйте хуки useMemo та useCallback для кешування обчислень і уникнення непотрібних перерахунків під час рендерингу.

5. Пакети компонентів (Component Libraries):

Використовуйте готові пакети компонентів (наприклад, Material-UI, Ant Design), які оптимізовані та протестовані з урахуванням продуктивності.

6. Віртуалізація списків:

Під час роботи з великими списками даних використовуйте бібліотеки віртуалізації (наприклад, react-virtualized), щоб рендерити тільки видимі елементи списку.

7. Оптимізація рендерінгу:

Уникайте непотрібних рендерів компонентів, використовуйте shouldComponentUpdate (у класових компонентах) або React.memo (у функціональних компонентах) для запобігання зайвим перемальовуванням.

8. Уникайте глибокої вкладеності:

Постарайтеся не створювати надто глибоку ієрархію компонентів, щоб зменшити час рендерингу та перерахунку.

9. Аналіз продуктивності:

Використовуйте інструменти, як-от React DevTools та браузерні інструменти продуктивності, щоб аналізувати й оптимізувати продуктивність вашого застосунку.

10. Серверний рендеринг (Server-Side Rendering, SSR):

Якщо це доречно для вашого застосунку, розгляньте можливість використання SSR для поліпшення початкового завантаження та SEO.

Зверніть увагу, що оптимізація продуктивності залежить від конкретного контексту вашого застосунку. Рекомендується використовувати інструменти профілювання та вимірювати продуктивність після кожної оптимізації, щоб переконатися, що вона справді призводить до поліпшень.

## Що таке HOC (Higher-Order Component) у React?

Високорівневий компонент (Higher-Order Component, HOC) - це патерн у React, який дає змогу повторно використовувати логіку компонентів, абстрагуючи її від самих компонентів. HOC не є частиною API React, це радше патерн композиції компонентів.

HOC - це функція, яка приймає компонент і повертає новий компонент із додатковою логікою. HOC дають змогу винести загальні функціональні або структурні аспекти компонентів і повторно використовувати їх із різними компонентами.

Приклад HOC:

```
import React from "react";

const withLogger = (WrappedComponent) => {
  return class WithLogger extends React.Component {
    componentDidMount() {
      console.log("Рендерінг компонента");
    }

    render() {
      return <WrappedComponent {...this.props} />;
    }
  };
};

const MyComponent = () => {
  return <div>Вміст компонента</div>;
};

const EnhancedComponent = withLogger(MyComponent);

export default EnhancedComponent;
```

У цьому прикладі withLogger - це HOC, який додає логування в метод componentDidMount. Потім компонент MyComponent обгортається HOC, створюючи EnhancedComponent.

HOC дозволяє:

- Розширювати функціональність компонентів без зміни самих компонентів.
- Перевикористовувати код і логіку між різними компонентами.
- Створювати загальні патерни для логування, аутентифікації, обробки помилок та інших аспектів.

Однак, з розвитком React і появою хуків, частина функціональності HOC тепер може бути реалізована з використанням хуків, таких як useEffect, useContext та інших. У більшості випадків, використання хуків є кращим.

## В чем разница между HOC и компонентами с рендер-пропсами (render props)?

Як HOC (Високорівневий компонент, Higher-Order Component), так і компоненти з рендер-пропсами представляють патерни в React для повторного використання логіки між компонентами. Однак, у них є відмінності в тому, як їх реалізовано і як вони використовуються.

#### HOC (Higher-Order Component):

- HOC - це функція, яка приймає компонент і повертає новий компонент із додатковою логікою.
- HOC можна використовувати як обгортку для компонентів, додаючи до них загальну функціональність.
- HOC виконуються під час створення компонента, і логіка, додана HOC, застосовується під час кожного рендеринга.
- У HOC є доступ до життєвих циклів компонента і його стану.
- Приклад HOC - connect з бібліотеки Redux, який пов'язує компоненти зі сховищем стану.

#### Компоненти з рендер-пропсами (Render Props Components):

- Компонент із рендер-пропсами - це компонент, який приймає функцію як властивість і викликає цю функцію для рендерингу чого-небудь.
- Компонент із рендер-пропсами дає змогу передавати логіку рендерингу безпосередньо в компонент, який використовує цей компонент із рендер-пропсами.
- Логіка рендерингу передається через функцію-пропс і може бути використана за потреби.
- Компонент з рендер-пропсами не має доступу до життєвих циклів батьківського компонента, але може мати доступ до стану через пропси.
- Приклад компонента з рендер-пропсами - компоненти Mouse або Toggle в документації React.

Вибір між HOC і компонентами з рендер-пропсами залежить від конкретної ситуації та вподобань розробника. Обидва патерни дають змогу досягти повторного використання логіки, але з різними підходами.

## Что такое рефы (refs) в React и как они используются?

Refs (скорочення від references) - це механізм у React, який дає змогу отримувати прямий доступ до DOM-елементів або компонентів, створених у React. Вони дають змогу вам звертатися до елементів, оновлювати їхні властивості та викликати методи компонентів без використання пропсів або стану.

Refs корисні, коли вам потрібно взаємодіяти з DOM елементами безпосередньо або отримувати доступ до методів і властивостей компонентів, які не доступні через пропси.

#### Створення рефів

Існує два способи створення рефів:

1. З використанням `React.createRef()` (class components):

```
import React, { Component } from "react";

class MyComponent extends Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }

  render() {
    return <div ref={this.myRef}>Вміст компоненту</div>;
  }
}
```

2. З використанням колбека (functional components):

```
import React, { useRef } from "react";

const MyComponent = () => {
  const myRef = useRef();

  return <div ref={myRef}>Вміст компоненту</div>;
};
```

#### Використання рефів

Рефи можуть використовуватися для доступу до DOM-елементів або компонентів:

```
class MyComponent extends Component {
  constructor(props) {
    super(props);
    this.myInputRef = React.createRef();
  }

  focusInput() {
    this.myInputRef.current.focus(); // Фокус на input елементі
  }

  render() {
    return <input ref={this.myInputRef} />;
  }
}
```

```
const MyComponent = () => {
  const myButtonRef = useRef();

  const handleClick = () => {
    myButtonRef.current.textContent = "Кнопку натиснуто";
  };

  return (
    <div>
      <button ref={myButtonRef} onClick={handleClick}>
        Натисни мене
      </button>
    </div>
  );
};
```

#### Які є нюанси?

- Використовуйте рефи з обережністю, оскільки це може порушити концепцію управління станом у React.
- У більшості випадків краще уникати використання рефів і віддавати перевагу роботі з даними через стан і пропси.

## Як реалізувати анімацію в React-додатку?

У React анімації можуть бути реалізовані з використанням різних методів і бібліотек. Ось кілька способів, як це можна зробити:

1. CSS Анімації та Транзиції:
   Ви можете використовувати CSS для створення анімацій і транзицій. Додайте класи з анімацією або транзицією до елементів і змінюйте їхні стилі за допомогою JavaScript або стану компонентів.

2. React Transition Group:
   Це бібліотека, яка полегшує створення анімацій під час додавання, оновлення або видалення компонентів. Вона надає компоненти для управління анімаціями на рівні компонентів.

3. React Spring:
   Це потужна бібліотека для фізичних анімацій (пружинних анімацій). Вона надає хуки та компоненти для створення плавних анімацій.

4. CSS-in-JS бібліотеки:
   Бібліотеки, як-от styled-components і emotion, дають змогу створювати стилі та анімації безпосередньо в JavaScript. Вони надають механізми для створення анімацій на основі стану компонентів.

5. Бібліотеки для анімації SVG:
   Якщо ви працюєте з SVG, ви можете використовувати бібліотеки, як-от react-spring-svg, для анімування SVG елементів.

6. Бібліотеки для анімованих переходів:
   Якщо вам потрібні складні анімовані переходи між різними сторінками, ви можете використовувати бібліотеки, такі як react-router-transition, які надають механізми для анімації переходів між маршрутами.

Приклад використання React Transition Group:

```
import React from "react";
import { CSSTransition } from "react-transition-group";
import "./MyComponent.css";

const MyComponent = ({ show }) => {
  return (
    <CSSTransition in={show} timeout={400} classNames="fade" unmountOnExit>
      <div className="my-component">Вміст компонента</div>
    </CSSTransition>
  );
};

export default MyComponent;
```

У цьому прикладі, коли show дорівнює true, компонент буде анімований під час появи та зникнення за допомогою CSS класів і транзицій.

Зверніть увагу: При створенні анімацій, особливо складних, слід враховувати продуктивність і подбати про те, щоб анімації не сповільнювали роботу вашої програми.

## Як працює механізм "контексту" (context) для передачі даних?

Механізм "контексту" (context) в React дає змогу передавати дані глибоко вниз по дереву компонентів без явної передачі через пропси на кожному рівні. Це особливо корисно, коли кілька компонентів потребують доступу до одних і тих самих даних.

Контекст складається з двох частин:

1. "постачальник" або "провайдер" (provider);
2. "споживач" (consumer).

**Постачальник (Provider):**
Постачальник визначає дані, які слід передати. Він обертає дерево компонентів, які мають отримати доступ до цих даних, і надає методи для їхнього доступу.

**Споживач (Consumer):**
Споживач використовує методи, надані постачальником, для доступу до даних, переданих через контекст.

Приклад використання контексту:

```
import React, { createContext, useContext } from "react";

// Створюємо контекст
const MyContext = createContext();

// Поставщик данных
const MyProvider = ({ children }) => {
  const sharedData = { message: "Повідомлення з контексту" };

  return <MyContext.Provider value={sharedData}>{children}</MyContext.Provider>;
};

// Компонент-споживач
const MyComponent = () => {
  const data = useContext(MyContext);

  return <div>{data.message}</div>;
};

// Всередині компонента App
function App() {
  return (
    <MyProvider>
      <MyComponent />
    </MyProvider>
  );
}
```

У цьому прикладі компонент `MyComponent` використовує `useContext` для доступу до даних, переданих через контекст. Коли `MyComponent` рендериться всередині `MyProvider`, він автоматично отримує доступ до даних, які були передані через контекст.

Контекст слід використовувати обережно, оскільки він може ускладнити відстеження передачі даних у додатку. Він найбільш корисний для передачі даних, які вважаються глобальними або загальними для багатьох компонентів.

## Що таке портали (portals) у React?

Портали (portals) - це механізм у React, який дає змогу рендерувати дочірні елементи в DOM-вузли, які знаходяться поза ієрархією DOM-компонента. Це означає, що ви можете рендерити вміст компонента в інший елемент поза поточним деревом компонентів.

Портали корисні, коли вам потрібно рендерити компоненти на верхньому рівні DOM (наприклад, для створення модальних вікон або спливаючих підказок), але зберегти логіку і стан компонента всередині вашого React-додатку.

Приклад використання порталів:

```
import React from "react";
import ReactDOM from "react-dom";

const Modal = ({ children }) => {
  const modalRoot = document.getElementById("modal-root");
  return ReactDOM.createPortal(children, modalRoot);
};

const App = () => {
  return (
    <div>
      <p>Вміст основного компонента</p>
      <Modal>
        <p>Вміст модального вікна</p>
      </Modal>
    </div>
  );
};

ReactDOM.render(<App />, document.getElementById("root"));
```

У цьому прикладі компонент `Modal` використовує портали для рендерингу свого вмісту в DOM-вузлі з id `modal-root`. По суті, `Modal` створює "спливаюче" вікно, яке рендерується на рівні верхнього рівня, але все ще має доступ до стану і методів компонента `App`.

Важливо зазначити, що портали не змінюють ієрархію компонентів у React-додатку, вони просто рендерять вміст в іншому місці в DOM.

## Як реалізувати lazy loading у React з використанням Suspense?

Ледаче завантаження (lazy loading) у React дає змогу відкладати завантаження компонентів доти, доки вони дійсно не знадобляться. Це може поліпшити продуктивність програми, зменшивши початковий час завантаження.

Для реалізації ледачого завантаження з використанням `Suspense`, ви можете використовувати функцію `React.lazy()`, яка дає змогу ледаче завантажувати динамічні імпорти компонентів. Однак, `React.lazy()` працює тільки з дефолтними експортами компонентів.

Ось як це можна зробити:

1. Створіть компонент, що ліниво завантажується:

```
// LazyComponent.jsx
import React from "react";

const LazyComponent = () => {
  return <div>Ліниво завантажений компонент</div>;
};

export default LazyComponent;
```

2. Використовуйте `React.lazy()` для ледачого завантаження:

```
import React, { Suspense } from "react";

const LazyComponent = React.lazy(() => import("./LazyComponent"));

const App = () => {
  return (
    <div>
      <p>Вміст основного компоненту</p>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
};

export default App;
```

У цьому прикладі `React.lazy()` використовується для ледачого завантаження компонента `LazyComponent`. Обертання `<LazyComponent />` в `<Suspense>` дає змогу вказати компонент-заглушку, який буде показано під час завантаження.

При використанні ледачого завантаження через `React.lazy()`, не забудьте, що це працює тільки з дефолтними експортами компонентів. Якщо ви хочете ліниво завантажити компоненти з іменованими експортами, ви можете використовувати альтернативний підхід з `import()`:

```
const LazyComponent = React.lazy(() => import("./LazyComponent"));
```

## Які нововведення було додано в React 16?

React 16, також відомий як React Fiber, вніс безліч значних змін і нововведень:

1. Fiber Architecture:
   Було запроваджено нову архітектуру під назвою Fiber, яка дала змогу React більш ефективно обробляти оновлення компонентів, роблячи додатки більш чуйними.

2. Portals:
   Було додано можливість використовувати Portals, що дають змогу рендерити дочірні компоненти за межами ієрархії DOM-вузлів батьківського компонента. Це корисно, наприклад, для створення модальних вікон або спливаючих меню.

3. Error Boundaries:
   Введено Error Boundaries, які дають змогу ізолювати помилки в компонентах, запобігаючи падінню всієї програми. Це допомагає поліпшити стабільність інтерфейсу.

4. Fragment:
   З'явився новий компонент Fragment, який дає змогу групувати дочірні елементи без додавання зайвих DOM-вузлів.

5. Сustom DOM Attributes:
   Тепер можна передавати користувацькі атрибути в DOM-елементи без попереджень.

6. Server-Side Rendering Improvements:
   Покращення в механізмах SSR (Server-Side Rendering) за допомогою нових API та оптимізацій.

7. Return Types:
   Введено нові типи значень, що повертаються, для компонентів, як-от string і number, що дає змогу використовувати елементи, що повертаються функціональними компонентами, як дочірні елементи.

8. Підтримка Map та Set:
   React Elements тепер можуть бути створені з екземплярів Map і Set.

9. Компактніший React:
   Розмір бібліотеки було зменшено за рахунок оптимізацій і видалення застарілого коду.

10. Нові Warnings і Deprecations:
    Було внесено зміни в систему попереджень, а також видалено застарілі методи.

11. Новий рендерер:
    Додано новий експериментальний рендерер під назвою Scheduler, який дає змогу контролювати пріоритети рендерінгу для кращої чуйності інтерфейсу.

12. Подієвий обробник onFocus:
    Введено підтримку обробника onFocus для обробки фокусування на елементах.

13. Новий атрибут forwardRef:
    Додано атрибут forwardRef, що спрощує передавання ref'ів між компонентами.

## Як використовувати React DevTools для налагодження програми?

React DevTools - це інструмент для розробників, який надає зручні засоби для налагодження та аналізу React-додатків. Ось як використовувати React DevTools для налагодження:

1. Встановлення та налаштування:

- Переконайтеся, що ви встановили React DevTools у вашому браузері. Ви можете знайти його в магазині розширень браузера.
- Після встановлення перезапустіть браузер, щоб зміни набули чинності.

2. Відкриття DevTools:

- Відкрийте веб-додаток, який ви хочете налагодити.
- Натисніть правою кнопкою миші в будь-якому місці сторінки та виберіть "Дослідити елемент" або "Переглянути код" (залежно від браузера). Це відкриє інструменти розробника.

3. Вкладка React:

- В інструментах розробника знайдіть вкладку з назвою "React" або "React" (залежно від браузера та версії DevTools). Зазвичай вона розташована поруч із вкладками "Елементи" та "Консоль".
- Перейдіть на цю вкладку.

4. Інспектування компонентів:

- У React DevTools ви побачите ієрархію компонентів вашої програми.
- Ви можете розкривати компоненти, щоб бачити їхній стан і властивості.
- Виділіть компонент, щоб бачити його поточний стан і пропси праворуч.

5. Зміна стану:

Якщо ви працюєте з компонентами, заснованими на класах, ви можете взаємодіяти з компонентами, змінюючи їхні стани та пропси, натискаючи на них у DevTools.

6. Відстеження оновлень:

React DevTools дає змогу відстежувати, які компоненти були оновлені під час зміни стану або пропсів. Ви побачите, які компоненти перемальовуються, а які ні.

7. Профілювання:

React DevTools також надає інструменти для профілювання продуктивності вашого застосунку, що дає змогу виявити вузькі місця в продуктивності та оптимізувати код.

8. Відстеження помилок:

Якщо у вашому додатку виникають помилки, React DevTools може допомогти вам їх легко відстежити і простежити до конкретних компонентів.

Використання React DevTools істотно полегшує налагодження та аналіз React-додатків, допомагаючи розробникам легко розуміти, як компоненти взаємодіють і як зміни стану впливають на інтерфейс.

## Що таке "хуки" (hooks) у React і для чого вони використовуються?

Хуки (hooks) у React - це функції, які дають змогу вам "зачепитися" за внутрішній стан і функціональність React компонентів. Вони були представлені в React 16.8 і дали змогу функціональним компонентам використовувати стан та інші можливості, які раніше були доступні тільки класовим компонентам. Хуки дають змогу писати чистіший, читабельніший і перевикористовуваний код.

#### Приклади хуків:

1. **useState:**
   Дозволяє функціональним компонентам мати локальний стан. Ви можете визначити змінні стану та функції для їхнього оновлення. Приклад:

```
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Підрахунок: {count}</p>
      <button onClick={() => setCount(count + 1)}>Збільшення</button>
    </div>
  );
}
```

2. **useEffect:**
   Дозволяє виконувати побічні ефекти у функціональних компонентах. Наприклад, виконання коду після рендерингу компонента, робота з асинхронними запитами і підписками. Приклад:

```
import React, { useState, useEffect } from "react";

function DataFetching() {
  const [data, setData] = useState([]);

  useEffect(() => {
    fetchData(); // Тут може бути код для отримання даних
  }, []);

  return (
    <ul>
      {data.map((item) => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

3. **useContext**:
   Дозволяє отримувати доступ до контексту з компонента. Контекст - це спосіб передачі даних глибоко в дерево компонентів без явної передачі через пропси. Приклад:

```
import React, { useContext } from "react";
import { ThemeContext } from "./ThemeContext";

function ThemedButton() {
  const theme = useContext(ThemeContext);

  return (
    <button style={{ background: theme.background, color: theme.color }}>
      Тематична кнопка
    </button>
  );
}
```

Хуки дають змогу розбивати логіку на дрібніші й керованіші частини, роблячи компоненти чистішими та легшими для тестування. Вони також усувають необхідність у класових компонентах у більшості випадків, що робить код зрозумілішим і скорочує обсяг бойлерплейта.

## Як створити власний хук у React?

Створення власних хуків дає змогу абстрагувати та перевикористовувати логіку між різними компонентами. Щоб створити власний хук, виконайте такі кроки:

1. Створення функції хука:

Створіть функцію, яка представлятиме ваш хук. Назва хука зазвичай починається з "use", щоб відповідати угоді і щоб React правильно його розпізнавав як хук.

Ця функція може містити будь-яку логіку, яку ви хочете розділити між компонентами.

2. Визначення стану та функцій оновлення (за необхідності):

Якщо ваш хук повинен керувати станом, використовуйте `useState` для створення стану та функцій для його оновлення.

3. Повернення даних і функцій:

Поверніть дані та функції, які компоненти будуть використовувати. Зазвичай це робиться у вигляді об'єкта.

4. Використання хука в компоненті:

Імпортуйте ваш хук у компонент, де ви хочете використовувати цю логіку.
Викличте функцію хука в компоненті та отримайте необхідні дані та функції.

Ось приклад, як це може виглядати:

```
import { useState } from "react";

// Створюємо власний хук
function useCounter(initialCount) {
  const [count, setCount] = useState(initialCount);

  const increment = () => {
    setCount(count + 1);
  };

  const decrement = () => {
    setCount(count - 1);
  };

  return {
    count,
    increment,
    decrement,
  };
}

// Використовуємо хук у компоненті
function CounterComponent() {
  const { count, increment, decrement } = useCounter(0);

  return (
    <div>
      <p>Порахуйте: {count}</p>
      <button onClick={increment}>Збільшення</button>
      <button onClick={decrement}>Відкладення</button>
    </div>
  );
}
```

Створений хук `useCounter` інкапсулює стан лічильника і функції для його оновлення. Це дає змогу використовувати ту саму логіку лічильника в різних компонентах без дублювання коду.

Зверніть увагу, що хуки не можуть бути асинхронними, і їх не можна викликати всередині умов або циклів, адже порядок викликів хуків у компоненті має бути постійним.

## Як обробляти помилки в React-додатку за допомогою Error Boundary?

Error Boundary (граничні помилки) в React - це компоненти, які обертають інші компоненти і дають змогу перехоплювати й обробляти помилки, що сталися в дочірніх компонентах під час рендерингу. Вони запобігають "провалюванню" помилок на рівень вище і дають змогу гладко обробити проблеми в інтерфейсі.

#### Ось як створити Error Boundary:

1. Створення Error Boundary компонента:

Створіть новий компонент, який слугуватиме вам як Error Boundary.

Він має реалізувати методи `componentDidCatch(error, info)`.

2. Обробка помилок у методі `componentDidCatch`:

У методі `componentDidCatch` ви можете обробити помилку, наприклад, показавши користувачеві повідомлення або записавши деталі помилки в логи.

3. Використання Error Boundary:

Оберніть компоненти, які ви хочете захистити, всередині створеного Error Boundary компонента.

Коли помилка станеться всередині дочірніх компонентів, Error Boundary перехопить її і спрацює метод componentDidCatch.

Приклад:

```
import React, { Component } from "react";

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
    };
  }

  componentDidCatch(error, info) {
    this.setState({ hasError: true });
    // Тут можна виконати логування або інші дії з обробки помилки
  }

  render() {
    if (this.state.hasError) {
      return <div>Щось пішло не так. Ми працюємо над цією проблемою.</div>;
    }
    return this.props.children;
  }
}

// Застосування Error Boundary
class App extends Component {
  render() {
    return (
      <div>
        <h1>Мій застосунок</h1>
        <ErrorBoundary>
          {/* Компоненти, які будуть захищені від помилок */}
        </ErrorBoundary>
      </div>
    );
  }
}
```

Важливо зазначити, що Error Boundary не перехоплює помилки в асинхронних операціях, усередині подієвих обробників або всередині інших Error Boundary. Тому гарною практикою є обертання лише тих компонентів, які є окремими модулями та ймовірно можуть спричинити помилки.

## Як працює алгоритм узгодження (reconciliation) у React?

Алгоритм узгодження в React - це процес порівняння віртуального DOM (VDOM) попереднього і поточного станів компонента, щоб визначити, які зміни необхідно внести в реальний DOM для відображення нового стану. Він дає змогу мінімізувати зміни в DOM і забезпечує ефективне оновлення інтерфейсу.

#### Ось як працює алгоритм узгодження:

1. Створення віртуального DOM:

Під час першого рендерінгу компонента React створює віртуальне дерево елементів (віртуальний DOM), що представляє структуру компонентів і їхні властивості.

2. Порівняння віртуальних DOM:

Коли компонент перемальовується, React створює нове віртуальне дерево для нового стану.

Потім порівнює нове віртуальне дерево з попереднім, враховуючи ієрархію і ключі елементів.

3. Визначення змін:

У результаті порівняння React визначає, які елементи змінилися, які додалися або видалені.

Ключі елементів допомагають React визначити, які елементи перемістилися, а які змінені.

4. Генерація пакета змін (diff):

На основі визначених змін React генерує пакет змін (diff), який описує, які зміни потрібно внести в реальний DOM.

5. Застосування змін у DOM:

React застосовує пакет змін до реального DOM.

Це може включати вставку, оновлення або видалення елементів залежно від типу змін.

6. Виклик методів життєвого циклу:

Після оновлення реального DOM React викликає відповідні методи життєвого циклу компонентів (наприклад, `componentDidUpdate`).

7. Асинхронність і пакетна обробка:

React може групувати кілька оновлень в одну операцію, щоб зменшити кількість змін у DOM та оптимізувати продуктивність.

React також може оптимізувати порядок оновлень для ефективнішого застосування змін.

Алгоритм узгодження дає змогу React рендерити компоненти ефективно, мінімізуючи кількість дорогих операцій оновлення DOM. Це робить React потужною бібліотекою для створення швидких і чуйних користувацьких інтерфейсів.

## Які популярні бібліотеки для управління станом ви знаєте, крім вбудованого `useState`?

Крім вбудованого useState у React, існує низка популярних сторонніх бібліотек для керування станом у застосунках. Деякі з них:

**1) Redux: **Одна з найпопулярніших бібліотек для управління станом. Вона надає передбачуваний спосіб організації стану, централізоване сховище та дії для зміни стану. Redux широко використовується у великих і складних додатках.

**2) Mobx:** Ще одна бібліотека управління станом, яка забезпечує реактивне програмування. Mobx дає змогу визначати спостережувані дані й автоматично оновлювати компоненти в разі їхньої зміни.

**3) Mobx-State-Tree (MST):** Це розширення Mobx, що надає більш сувору структуру для організації стану програми. MST дає змогу створювати моделі даних із певними типами, діями та обчислюваними значеннями.

**4) Zustand:** Це легка бібліотека управління станом, яка підходить для невеликих і середніх додатків. Вона використовує функціональне програмування та хук useReducer, щоб надати простий API для роботи зі станом.

**5) Recoil: **Бібліотека, розроблена Facebook, яка призначена для управління станом у React-додатках. Вона ґрунтується на концепції атомів і селекторів, що дає змогу більш декларативно описувати стан і його залежності.

**6) Easy Peasy: **Це бібліотека, створена на основі Redux, але зі спрощеним синтаксисом. Вона надає більш легке та інтуїтивне API для управління станом.

**7) Valtio:** Ще одна легка бібліотека для управління станом. Вона використовує проксі-об'єкти для відстеження змін та автоматичного оновлення компонентів.

Кожна з цих бібліотек має свої особливості та підходи до управління станом у React-додатках. Вибір бібліотеки залежить від складності програми, ваших уподобань і досвіду.

## Каким образом можно оптимизировать рендеринг компонентов в React?

Оптимізація візуалізації компонентів у React допомагає поліпшити продуктивність вашого застосунку та забезпечити більш плавний користувацький досвід. Ось кілька способів, як можна оптимізувати рендеринг компонентів:

**1) Використання ключів (Keys):**

Під час відображення списків елементів у React, приділяйте увагу унікальним ключам (key).

Ключі допомагають React визначити, які елементи були додані, змінені або видалені, що допомагає скоротити кількість змін у DOM.

**2) Уникнення непотрібних рендерів:**

Використовуйте методи `shouldComponentUpdate` (у класових компонентах) або `React.memo` (у функціональних компонентах), щоб запобігти непотрібним перемальовуванням.

Вони дають змогу перевірити, чи дійсно компонент потрібно оновлювати під час зміни стану або пропсів.

**3) Використання PureComponent та memo:**

Скористайтеся `PureComponent` (у класових компонентах) або `React.memo` (у функціональних компонентах) для автоматичної перевірки змін пропсів і стану перед оновленням компонента.

**4) Поділ компонентів:**

Розбийте великі компоненти на дрібніші, щоб зменшити сферу оновлення і зробити код більш модульним.

**5) Використання хуків:**

Хуки, як-от `useMemo` чи `useCallback`, дають змогу кешувати значення і колбеки, що зменшує надлишкові обчислення та оновлення.
** 6) Ліниве завантаження (Lazy Loading):**

Використовуйте ледаче завантаження для окремих компонентів за допомогою `React.lazy` та `Suspense`, щоб завантажувати компоненти тільки тоді, коли вони дійсно знадобляться.

**7) Оптимізовані список:**

Для відображення великих списків використовуйте бібліотеки, такі як `react-virtualized` або `react-window`, щоб візуалізувати лише видимі елементи.

**8) Пакетне оновлення (Batching):**

React автоматично групує кілька оновлень стану або пропсів в одну операцію, щоб зменшити кількість змін у DOM.

**9) Використання Production Build:**

Під час розгортання застосунку використовуйте оптимізований "production" білд React, який включає мінімізований код та інші оптимізації.

**10) Профілювання:**

Використовуйте інструменти профілювання React, такі як React DevTools Profiler, щоб виявити вузькі місця в продуктивності та оптимізувати їх.

Оптимізація візуалізації компонентів - це постійний процес, оскільки продуктивність може залежати від конкретного застосунку та його контексту. Регулярне вивчення нових інструментів і методів допоможе поліпшити продуктивність вашого React-додатку.

## Що таке "глибоке порівняння" (deep comparison) у контексті оптимізації продуктивності React?

"Глибоке порівняння" (deep comparison) - це процес порівняння двох об'єктів або структур даних на основі їхніх внутрішніх значень, а не на основі посилань або ідентифікаторів. У контексті оптимізації продуктивності React, глибоке порівняння використовується для визначення, чи змінилися дані в компонентах, і чи варто перемальовувати компонент через ці зміни.

Під час роботи з React, компоненти можуть перемальовуватися під час зміни стану або пропсів. Однак, якщо компонент перемальовується занадто часто, це може негативно позначитися на продуктивності, оскільки кожне оновлення компонента вимагає виконання низки операцій, включно з генерацією віртуального DOM і оновленням реального DOM.

Щоб уникнути надлишкових перемальовувань, React використовує механізми оптимізації, такі як "поверхневе порівняння" (shallow comparison) і "глибоке порівняння" (deep comparison).

1. Поверхневе порівняння (Shallow Comparison):

Під час поверхневого порівняння React порівнює значення пропсів і стани компонентів. Якщо значення не змінилися, React припускає, що компонент можна не перемальовувати.

2. Глибоке порівняння (Deep Comparison):

Глибоке порівняння використовується, коли дані являють собою складні структури, наприклад, вкладені об'єкти або масиви. У цьому випадку React перевіряє не тільки посилання на об'єкти, а й їхній вміст.

Якщо будь-які вкладені дані змінилися, компонент буде перемальований.

Однак глибоке порівняння може бути ресурсоємним, особливо для великих структур даних. Тому, у певних випадках, корисно використовувати методи оптимізації, як-от `React.memo` (у функціональних компонентах) або `shouldComponentUpdate` (у класових компонентах), щоб керувати поведінкою перемальовок на основі глибокого порівняння.

## Як використовувати memoization для оптимізації компонентів?

Memoization - це техніка оптимізації, яка дає змогу кешувати результати виконання функції та використовувати їх під час повторних викликів із тими самими аргументами. Це може бути корисно, коли компоненти вашого застосунку мають високу обчислювальну складність і часто викликаються з одними й тими самими вхідними даними.

Для використання **memoization** ви можете використовувати різні підходи. Одним із поширених є використання бібліотеки memoizee для JavaScript. Вона надає декоратори, які можна застосовувати до функцій, щоб автоматично кешувати їхні результати.

Ось приклад використання memoizee:

```
const memoize = require("memoizee");

const expensiveFunction = (param) => {
  // Деякі дорогі обчислення...
  повернути result;
};

const memoizedFunction = memoize(expensiveFunction);

// Тепер при повторних викликах з тими самими аргументами
// буде використовуватися кешований результат

const result1 = memoizedFunction("param1");
const result2 = memoizedFunction("param2");
const result3 = memoizedFunction("param1"); // Буде використано кешований результат

console.log(result1);
console.log(result2);
console.log(result3);
```

Таким чином, завдяки **memoization** можна істотно знизити кількість повторних обчислень і поліпшити продуктивність компонентів.

## Які патерни використання Redux ви знаєте?

**Redux** - це популярна бібліотека для управління станом програми в JavaScript. Вона пропонує низку патернів використання, які допомагають організувати код і полегшити розробку. Ось деякі з них:

**1) Action-Creator Pattern: **
Цей патерн полягає у створенні функцій-творців дій (action creators), які повертають об'єкти з інформацією про подію або запит до зміни стану. Наприклад, const increment = (amount) => { return { type: 'INCREMENT', payload: amount }; }. Це допомагає стандартизувати створення дій і зробити їх зручнішими для використання.

**2) Reducer Pattern: **
У Redux редьюсери (reducers) використовуються для визначення, як змінюється стан застосунку під час отримання дій. Редьюсер - це чиста функція, яка приймає поточний стан і дію, і повертає новий стан. Паттерн пропонує розділити зміну стану на невеликі функції, кожна з яких відповідальна за зміну своєї частини стану.

**3) Store Pattern: **
Центральним пунктом у Redux є сховище (store), яке містить увесь стан застосунку. Сховище дає змогу отримувати поточний стан, оновлювати його за допомогою дій і підписуватися на зміни стану для оновлення користувацького інтерфейсу.

**4) Middleware Pattern: **
Redux надає можливість використовувати middleware - проміжні шари для обробки дій перед їхнім досягненням до редьюсерів. Це дає змогу виконати додаткові дії, як-от логування, опрацювання асинхронних запитів або зміна дій перед їхнім опрацюванням. Прикладами middleware у Redux є redux-thunk і redux-saga.

**5) Container and Presentational Components Pattern: **
Цей патерн пропонує розділити компоненти на дві категорії: контейнерні компоненти (container components), які відповідають за під'єднання до сховища та передавання даних; та презентаційні компоненти (presentational components), які займаються лише візуалізацією та зворотним зв'язком із користувачем. Це покращує читабельність, перевикористовуваність і тестованість компонентів.

Це лише деякі патерни, які можна використовувати з Redux. Кожен із них має свої переваги і може бути застосований залежно від вимог і складності вашого застосунку.

## Як працює бібліотека React Router?

React Router - це популярна бібліотека для керування маршрутизацією (навігацією) у додатках на основі React. Вона дає змогу створювати односторінкові додатки (SPA), де контент змінюється динамічно без повного перезавантаження сторінки. Ось як працює React Router:

**1) Встановлення та налаштування: **

Спочатку потрібно встановити React Router за допомогою пакетного менеджера, наприклад, npm або yarn. Після встановлення необхідно імпортувати компоненти з бібліотеки та налаштувати маршрути для застосунку.

**2) Визначення маршрутів: **

Ви визначаєте маршрути у вашому застосунку за допомогою компонентів, що надаються React Router, таких як:

- BrowserRouter,
- Route,
- Switch
- Link.

Компонент `BrowserRouter` обертає кореневий компонент додатка і забезпечує навігацію.

**3) Компоненти маршрутизації: **

Ви використовуєте компоненти `Route`, щоб пов'язати певні маршрути з відповідними компонентами. Наприклад, ви можете визначити маршрут "/about" і пов'язати його з компонентом `About`.

**4) Навігація: **

Для створення посилань між різними маршрутами ви використовуєте компонент `Link`. Він дозволяє створювати клікабельні посилання, які перемикаються між маршрутами без повного перезавантаження сторінки.

**5) Перемикання між маршрутами: **

Коли користувач переходить за посиланням або вводить URL, React Router визначає відповідний маршрут і рендерить відповідний компонент, пов'язаний із цим маршрутом.

**6) Додаткові можливості: **

React Router також надає додаткові функції, як-от параметри маршрутів, вкладені маршрути, захист маршрутів тощо.

Загалом, React Router спрощує управління навігацією у вашому React-додатку, забезпечуючи плавні переходи між різними "сторінками" в межах однієї сторінки.

## Що таке SSR (Server-Side Rendering) і як він відрізняється від CSR (Client-Side Rendering)?

SSR (Server-Side Rendering) - це метод веб-розробки, за якого контент веб-сторінки генерується на сервері та потім відправляється браузеру як повністю сформована HTML-сторінка. Це дає змогу браузеру одразу ж відобразити контент, що позитивно впливає на SEO, індексацію та час завантаження сторінки для користувачів, особливо за повільного інтернет-з'єднання.

#### У чому різниця між SSR і CSR?

**CSR (Client-Side Rendering)** - це підхід, за якого вся логіка відображення контенту відбувається в браузері. Спочатку сервер відправляє мінімальний HTML і JavaScript, а потім браузер завантажує скрипти і запитує дані для відображення. Це може створювати більш інтерактивні користувацькі інтерфейси, але також може спричиняти повільне завантаження сторінки і проблеми з SEO.

##### Основні відмінності:

1. Завантаження сторінки:

У SSR більша частина контенту вже є у вихідному HTML, тому сторінка швидше відображається. У CSR контент генерується браузером після завантаження скриптів, що може викликати повільне початкове завантаження.

2. SEO:

SSR має перевагу для SEO, оскільки пошукові системи можуть легко проіндексувати контент на сторінці, оскільки він уже присутній у вихідному HTML. У CSR це вимагає додаткових зусиль для індексації.

3. Інтерактивність:

CSR може надавати більш плавні переходи та інтерактивність, оскільки більша частина роботи відбувається на стороні клієнта. У SSR інтерактивність обмежена тим, що було попередньо згенеровано на сервері.

Обидва підходи мають свої плюси і мінуси, і вибір між ними залежить від конкретних вимог проєкту і пріоритетів веб-розробників.

## Як реалізувати асинхронне завантаження компонентів за допомогою React Router?

Асинхронне завантаження компонентів, також відоме як "ледаче завантаження" (lazy loading), дає змогу завантажувати компоненти тільки тоді, коли вони справді потрібні, що може значно поліпшити продуктивність вашого застосунку. У React Router для цього використовується функція `React.lazy()` у поєднанні з динамічним імпортом і `Suspense`. Ось як це робиться:

1. Використання `React.lazy()`:

Ви можете використовувати функцію `React.lazy()` для асинхронного завантаження компонентів. Ця функція приймає функцію, що повертає проміс, який дозволяється в модуль із компонентом. Наприклад:

```
const MyComponent = React.lazy(() => import("./MyComponent"));
```

2. Додавання `Suspense`:

Коли ви використовуєте асинхронне завантаження, ви також маєте використати компонент `Suspense`, який очікуватиме завантаження асинхронних компонентів. Загорніть точку входу вашого додатка (зазвичай навколо компонента `<Router>`) у `<Suspense>` та вкажіть `fallback` - компонент, який відображатиметься під час завантаження:

```
import {
  BrowserRouter as Router,
  Route,
  Switch,
  Link,
} from "react-router-dom";

const MyComponent = React.lazy(() => import("./MyComponent"));

function App() {
  return (
    <Router>
      <div>
        <nav>
          <ul>
            <li>
              <Link to="/">Home</Link>
            </li>
            <li>
              <Link to="/lazy">Lazy Component</Link>
            </li>
          </ul>
        </nav>

        <hr />

        <Suspense fallback={<div>Loading...</div>}>
          <Switch>
            <Route exact path="/">
              {/* Рендер компонента для головної сторінки */}
            </Route>
            <Route path="/lazy" component={MyComponent} />
          </Switch>
        </Suspense>
      </div>
    </Router>
  );
}
```

Тепер, коли користувач перейде на маршрут `/lazy`, компонент `MyComponent` буде асинхронно завантажуватися тільки в момент його дійсного відображення на екрані. У цей час відобразиться `fallback` (у цьому випадку "Loading...").

Це дає змогу вашому застосунку ефективно використовувати ресурси, завантажуючи тільки ті компоненти, які дійсно потрібні користувачеві.

## Які переваги дає використання Redux для управління станом застосунку:

1. Централізоване сховище:
   Redux надає єдине централізоване сховище для всього стану вашого застосунку. Це робить управління та відстеження стану більш прозорим і передбачуваним.

2. Передбачуваність:
   Стан у Redux є незмінним, і його зміни відбуваються через чисті функції - редюсери. Це призводить до передбачуваної поведінки під час оновлення стану і легше виявляти помилки.

3. Спрощене управління станом:
   Redux надає патерн управління станом Flux, який спрощує складні випадки управління станом, особливо у великих додатках.

4. Легкість відстеження змін:
   Стан у Redux змінюється тільки через дії (actions), які явно описують, що відбулося в додатку. Це спрощує відстеження історії змін і налагодження.

5. Відокремлення стану від компонентів:
   Redux дає змогу відокремити стан застосунку від компонентів, що покращує масштабованість і дає змогу повторно використовувати компоненти.

6. Легкість тестування:
   Чисті функції редюсерів і передбачуваність змін стану роблять тестування Redux-логіки простішим і надійнішим.

7. Підтримка інструментів розробника:
   Існують інструменти розробника, як-от Redux DevTools, які полегшують відстеження та запис змін стану в часі.

8. Розширюваність:
   Redux має багату екосистему плагінів і засобів для поліпшення та розширення функціональності.

9. Сумісність із різними фреймворками:
   Redux можна використовувати не тільки з React, а й з іншими фреймворками та бібліотеками.

10. Покращене управління асинхронними операціями:
    За допомогою middleware, такого як Redux Thunk або Redux Saga, Redux спрощує управління асинхронними операціями, такими як запити до сервера.

Хоча Redux може додати деяку складність у маленьких проєктах, у великих і складних додатках його патерн та інструменти можуть істотно поліпшити організацію, масштабованість і обслуговуваність коду.

## Що таке Redux Thunk?

**Redux Thunk** - це middleware (проміжне програмне забезпечення) для Redux, яке дає змогу обробляти асинхронні дії (actions) у Redux-додатку. У Redux асинхронні операції, такі як запити до сервера, зазвичай не можуть бути виконані безпосередньо всередині дій через синхронну природу редюсерів. Redux Thunk вирішує цю проблему, дозволяючи створювати дії, які є функціями замість об'єктів.

#### Як це працює?

Звичайна дія Redux являє собою об'єкт, наприклад:

```
const action = {
  type: "SOME_ACTION",
  payload: someData,
};
```

З використанням Redux Thunk, дії стають функціями, які можуть виконувати асинхронні операції, і мають доступ до методу `dispatch` і поточного стану:

```
const asyncAction = () => (dispatch, getState) => {
  // Виконуємо асинхронні операції, наприклад, запит до сервера
  fetch("https://api.example.com/data")
    .then((response) => response.json())
    .then((data) => {
      dispatch({ type: "FETCH_SUCCESS", payload: data });
    })
    .catch((error) => {
      dispatch({ type: "FETCH_FAILURE", payload: error });
    });
};
```

Тут `asyncAction` - це функція, яка, коли викликається, повертає функцію з двома аргументами: `dispatch` та `getState`. Усередині цієї функції можна виконувати асинхронні операції та викликати `dispatch` для надсилання відповідних дій у стор Redux.

#### Переваги Redux Thunk:

1. Простота використання:
   Redux Thunk дає змогу створювати асинхронні дії з легкістю, не вимагаючи переходу до складніших бібліотек управління побічними ефектами, таких як Redux Saga або Redux Observable.

2. Інтеграція з наявним кодом:
   Redux Thunk добре інтегрується з наявним кодом Redux, тож ви можете поступово перекладати асинхронні операції на його використання без необхідності переписування всього коду.

3. Гнучкість:
   Redux Thunk дає вам більшу гнучкість у тому, як ви керуєте асинхронними операціями у вашому додатку.

## Як працює Redux Saga?

Redux Saga - це бібліотека для управління побічними ефектами в Redux-додатках. Вона надає альтернативний спосіб опрацювання асинхронних операцій, таких як запити до сервера, опрацювання подій та інші побічні ефекти. Ось як працює Redux Saga:

1. Генератори:
   Redux Saga використовує генератори, спеціальний тип функцій JavaScript, що дає змогу зупинити виконання функції, а потім відновити його. Генератори часто використовуються для представлення асинхронних операцій як послідовності кроків.

2. Ефекти:
   У Redux Saga операції, які представляють побічні ефекти, називаються "ефектами". Ефекти - це об'єкти, які описують, як Redux Saga має обробити побічні ефекти. Наприклад, `call` для виклику функцій, `put` для надсилання дій, `take` для очікування дій тощо.

3. Саги:
   Саги - це спеціальні генератори, які описують послідовність кроків для обробки певного типу побічних ефектів. Саги стежать за певними діями і, коли такі дії відбуваються, вони запускають відповідні генератори.

4. Middleware:
   Redux Saga підключається до Redux через middleware. Це означає, що саги працюють паралельно зі звичайними діями і редюсерами Redux, обробляючи побічні ефекти.

5. Асинхронні операції:
   Redux Saga обробляє асинхронні операції, як-от запити до сервера, створюючи саги, які слухають певні дії, запускають генератори для оброблення цих дій і взаємодіють з ефектами, як-от `call` і `put`, щоб керувати асинхронними операціями.

6. Скасування операцій:
   Однією з переваг Redux Saga є можливість легко скасовувати та контролювати асинхронні операції, використовуючи такі концепції як `takeLatest`, `takeEvery` тощо.

7. Тестування:
   Redux Saga має хорошу підтримку для тестування завдяки тому, що кожен етап саги може бути явно керований.

Redux Saga надає складніший, але потужніший підхід до управління побічними ефектами, що робить код більш структурованим і легшим для тестування.

## Як реалізувати ледаче завантаження Redux-редьюсерів?

Ледаче завантаження Redux-редьюсерів може бути корисним, коли у вас є великий Redux-додаток із безліччю редьюсерів, і ви хочете оптимізувати початкове завантаження програми. Redux дозволяє динамічно додавати редьюсери до сховища за допомогою методу `store.replaceReducer()`.

Ось як можна реалізувати ледаче завантаження Redux-редьюсерів:

1. Розділіть редьюсери за модулями:
   Замість того щоб мати один великий файл із редьюсерами, розділіть їх на модулі відповідно до функціональності або розділів програми.

2. Використовуйте `combineReducers` для кожного модуля:
   У кожному модулі створіть свій власний набір редьюсерів за допомогою функції `combineReducers` з Redux.

3. Створіть функцію для ледачого завантаження:
   Для кожного модуля створіть функцію, яка повертатиме проміс, що дозволяє `combineReducers` для цього модуля. Це можна зробити за допомогою динамічного імпорту.

Приклад:

```
// Модуль "counter"
export const loadCounterReducers = () =>
  import("./counter/reducers").then((module) => module.default);

// Модуль "user"
export const loadUserReducers = () =>
  import("./user/reducers").then((module) => module.default);
```

4. Динамічно підключіть редьюсери:
   У точці входу вашого застосунку (зазвичай у файлі, де ви створюєте сховище Redux), ви можете динамічно підключати редьюсери, використовуючи функції для ледачого завантаження і метод `store.replaceReducer()`:

```
import { createStore } з "redux";
import { loadCounterReducers, loadUserReducers } from "./lazyReducers";

const rootReducer = combineReducers({
  // Ваші початкові редюсери
});

const store = createStore(rootReducer);

// Завантажуємо редьюсери по мірі необхідності
loadCounterReducers().then((counterReducers) => {
  store.replaceReducer(
    combineReducers({
      ...rootReducer,
      ...counterReducers,
    })
  );
});

loadUserReducers().then((userReducers) => {
  store.replaceReducer(
    combineReducers({
      ...rootReducer,
      ...userReducers,
    })
  );
});
```

Зверніть увагу, що цей підхід може додати складності в управлінні станом і вимагає ретельного тестування. У великих додатках він може допомогти оптимізувати початкове завантаження і поліпшити продуктивність.

## Що таке "нормалізація стану" (state normalization) у контексті керування станом програми?

Нормалізація стану (state normalization) - це патерн управління станом, який використовується для організації даних у сховищі таким чином, щоб забезпечити ефективне зберігання, оновлення та доступ до даних у Redux або інших системах управління станом.

Основна ідея нормалізації полягає в тому, щоб зберігати дані в нормалізованій формі, де кожен тип даних зберігається в окремій колекції (таблиці), і використовуються посилання між різними колекціями для усунення дублювання даних і полегшення оновлення.

Приклад: Припустимо, у нас є список постів і список коментарів до цих постів. Замість зберігання коментарів усередині кожного поста (що може призвести до дублювання даних), ми можемо створити дві колекції: "пости" і "коментарі", і використовувати ідентифікатори постів у коментарях для встановлення зв'язку між ними.

#### Переваги нормалізації стану:

**1) Економія місця: **
Дублювання даних зменшується, оскільки одні й ті самі дані не зберігаються в декількох місцях.

**2) Легкість оновлення: **
Зміна даних в одній колекції автоматично відображається в інших, де ці дані використовуються.

**3) Швидкий доступ: **
Пошук, фільтрація і доступ до даних прискорюються, оскільки дані розділені на більш дрібні колекції.

**4) Прозорість: **
Структуру сховища стає легше зрозуміти і відстежити.

У той час як нормалізація може допомогти в оптимізації та управлінні станом, вона також додає складності в логіку оновлення даних і може вимагати додаткової роботи при виборі даних для відображення в компонентах. Вам варто вибрати підхід залежно від розміру та складності вашого застосунку.

## Як створити анімований перехід між сторінками за допомогою React Router?

Для створення анімованих переходів між сторінками з використанням React Router ви можете використовувати такий підхід:

1. Використовуйте CSS-анімації:
   Найпростіший спосіб додати анімацію - це використовувати CSS-анімації. Ви можете визначити анімацію для елементів, які з'являються або зникають під час переходу між сторінками.

2. Використовуйте бібліотеки анімацій:
   Існує безліч бібліотек анімацій, таких як `react-transition-group`, які спрощують створення анімацій переходів. Вони дають змогу вам вказати, які елементи мають анімуватися під час монтування та розмонтування.

Приклад використання `react-transition-group`:

```
import { CSSTransition } from "react-transition-group";
import { BrowserRouter as Router, Route, Switch, Link } from "react-router-dom";
import "./styles.css";

function App() {
  return (
    <Router>
      <div>
        <nav>
          <ul>
            <li>
              <Link to="/">Home</Link>
            </li>
            <li>
              <Link to="/about">About</Link>
            </li>
          </ul>
        </nav>

        <hr />

        <Switch>
          <Route exact path="/">
            <Home />
          </Route>
          <Route path="/about">
            <About />
          </Route>
        </Switch>
      </div>
    </Router>
  );
}

function Home() {
  return (
    <CSSTransition in={true} appear={true} timeout={300} classNames="fade">
      <div className="home">Home Page</div>
    </CSSTransition>
  );
}

function About() {
  return (
    <CSSTransition in={true} appear={true} timeout={300} classNames="fade">
      <div className="about">About Page</div>
    </CSSTransition>
  );
}
```

3. Користувацькі анімації:
   Якщо вам потрібна складніша анімація, ви можете створити свої власні анімації за допомогою бібліотек для анімацій, таких як `framer-motion` або `react-spring`.

Не забудьте налаштувати відповідні стилі та класи для анімацій у вашому CSS.

## Як працюють CSS-модулі (CSS Modules) у React?

CSS-модулі є підходом до організації стилів у додатку React, який допомагає ізолювати стилі компонентів і уникнути конфліктів імен класів. Ось як це працює:

**1) Створення модулів стилів: **
Для кожного компонента створюється файл із розширенням `.module.css` або аналогічне за допомогою препроцесорів. Наприклад, `Button.module.css`. У цьому файлі визначаються стилі як зазвичай, але імена класів перетворюються в унікальні імена.

**2) Використання стилів: **
У компоненті React ви можете імпортувати стилі з модуля, як звичайний об'єкт. Наприклад:

```
import React from 'react';
import styles from './Button.module.css';

const Button = () => {
  return <button className={styles.button}>Натисни мене</button>;
};

export default Button;
```

Тут `styles.button` - це унікальне ім'я класу з модуля стилів.

**3) Автоматична локалізація імен класів: **
Під час складання проєкту інструмент CSS-модулів автоматично генерує унікальні імена класів для кожного компонента. Це запобігає перетину стилів між різними компонентами.

**4) Локальні стилі: **
Стилі, визначені всередині модуля, обмежені областю видимості цього модуля. Вони не перетинаються з іншими стилями навіть у тому самому файлі.

**5) Підтримка CSS імен: **
Ви можете використовувати зрозумілі імена класів у ваших стилях, оскільки імена класів із модулів не конфліктуватимуть із глобальними іменами.

**6) Додаткові можливості: **
Деякі інструменти надають додаткові можливості, такі як успадкування стилів, глобальні стилі тощо, щоб полегшити управління стилями.

Використання CSS-модулів робить структуру стилів чіткішою та впорядкованішою, знижуючи ймовірність помилок і полегшуючи спільну розробку.

## Що таке Styled Components, і як воно використовується?

Styled Components - це бібліотека для стилізації компонентів у React. Вона надає можливість визначати стилі безпосередньо всередині компонентів з використанням синтаксису шаблонних рядків (template literals). Це дає змогу створювати компоненти, які містять як логіку, так і стилі, роблячи код більш читабельним і підтримуваним.

#### Ось як працює Styled Components:

1. Встановлення та імпорт:
   Почніть зі встановлення Styled Components через npm або yarn. Після встановлення ви можете імпортувати функції та компоненти з бібліотеки у свій проєкт.

2. Створення стилізованих компонентів:
   Для створення стилізованих компонентів використовуйте функції зі Styled Components.

Наприклад:

```
import styled from 'styled-components';

const Button = styled.button`
  background-color: #070707;
  color: white;
  border: none;
  padding: 15px 25px;
  cursor: pointer;
`;
```

Тут `styled.button` створює компонент `<button>`, до якого застосовано зазначені стилі.

3. Використання стилізованих компонентів:
   Тепер ви можете використовувати стилізований компонент `Button` так само, як і звичайний компонент:

```
import React from 'react';
import Button from './Button';

const App = () => {
  return (
    <div>
      <Button>Натисни мене</Button>
    </div>
  );
};

export default App;
```

4. Передача пропсів:
   Ви також можете передавати пропси в стилізовані компоненти та використовувати їх усередині рядків шаблону:

```
const Button = styled.button`
  background-color: ${(props) => (props.primary ? '#000000' : '#777777')};
  color: white;
  border: none;
  padding: 10px 20px;
  cursor: pointer;
`;
```

5. Глобальні стилі:
   Ви можете використовувати `createGlobalStyle` зі Styled Components для визначення глобальних стилів, які будуть застосовуватися до всього додатка.

Styled Components спрощує структурування та управління стилями у вашому проєкті, даючи змогу створювати компоненти, що включають у себе стилі та поведінку. Вона також забезпечує підтримку динамічних стилів і пропсів, що робить стилізацію компонентів більш гнучкою.

## Як передати дані з сервера на клієнт під час використання SSR у React?

Під час використання SSR (Server-Side Rendering) у React, дані можуть бути попередньо завантажені на сервері та передані клієнту для ініціалізації стану програми. Ось як це робиться:

1. Підготуйте сервер:
   Ваш сервер повинен мати можливість обробляти запити на серверний рендеринг і отримання даних. Для цього ви можете використовувати бібліотеки типу Express.js, Next.js або інші.

2. Завантажте дані на сервері:
   Під час обробки запиту на сервері ви можете завантажити дані з вашого API або іншого джерела даних. Ці дані будуть використані для ініціалізації стану на клієнті.

3. Передайте дані клієнту:
   Найпоширеніший спосіб передавання даних із сервера на клієнт - це вбудовування даних у HTML, що надсилається клієнту. Наприклад, ви можете використовувати `window.INITIAL_STATE` або якусь іншу глобальну змінну на клієнті, щоб зберегти дані.

4. Використовуйте дані на клієнті:
   Коли клієнтський код почне виконуватися, він може витягти передані дані з глобальної змінної та використати їх для ініціалізації стану програми.

Пример на Express.js:

```
import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';
import App from './App'; // Ваш компонент React
import fetchInitialData from './fetchInitialData'; // Функція для завантаження даних

const app = express();

app.get('/', async (req, res) => {
  try {
    const initialData = await fetchInitialData(); // Завантаження даних із сервера
    const appMarkup = renderToString(<App initialData={initialData} />);
    const html = `
      <html>
        <head>
          <title>SSR React App</title>
        </head>
        <body>
          <div id="root">${appMarkup}</div>
          <script>
            window.__INITIAL_DATA__ = ${JSON.stringify(initialData)};
          </script>
          <script src="bundle.js"></script>
        </body>
      </html>
    `;
    res.send(html);
  } catch (error) {
    console.error('Error during server rendering:', error);

    res.status(500).send('Internal Server Error');
  }
});

app.listen(3000, () => {
  console.log('Server is listening on port 3000');
});
```

На клієнті ви можете використовувати `window.__INITIAL_DATA__` для ініціалізації стану вашої програми переданими даними.

Не забудьте обробити помилки і подбати про безпеку під час передачі даних із сервера на клієнт.

## Які переваги та недоліки мають функціональні компоненти порівняно з компонентами класів?

Функціональні компоненти мають кілька переваг перед компонентами класів:

1. Простота і читабельність коду:
   Функціональні компоненти зазвичай записуються у вигляді звичайних функцій, що робить їхній код більш лаконічним і зрозумілим. Вони не вимагають успадкування і конструкторів, як класи.

2. Легше піддаються оптимізації:
   Функціональні компоненти дають змогу використовувати певні оптимізації, як-от мемоїзація, що може поліпшити продуктивність під час рендерингу.

3. Підтримка хуків (hooks):
   Функціональні компоненти можуть використовувати хуки, які надають зручніший спосіб керування станом і побічними ефектами.

4. Легше тестування:
   Функціональні компоненти можуть бути простішими для тестування завдяки своїй структурі та відсутності стану класів.

5. Тенденція розвитку:
   Більшість нових функцій і поліпшень у бібліотеках React та інших бібліотеках для інтерфейсів надаються спочатку для функціональних компонентів.

Однак у функціональних компонентів також є деякі недоліки:

1. Відсутність інкапсуляції:
   На відміну від класів, функціональні компоненти не можуть використовувати приватні методи або властивості без використання хуків або інших механізмів.

2. Складні стани:
   За наявності складних станів і складної логіки функціональні компоненти можуть стати заплутаними, особливо без правильного використання хуків.

3. Менша сумісність із деякими бібліотеками:
   Деякі сторонні бібліотеки та інструменти можуть передбачати використання класів і не завжди добре сумісні з функціональними компонентами.

4. Великі проекти:
   У великих проектах може бути складно підтримувати структуру функціональних компонентів без суворої організації коду.

Загалом, вибір між функціональними компонентами та компонентами класів залежить від конкретних вимог проєкту, структури команди розробників і особистих уподобань.
